local Library, SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jamalarap61/Mslspakwnendlsowjnssoaknana/refs/heads/main/wnsoaowknswlwksnwmk.lua"))()


function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end


local Window = Library:CreateWindow({
    Title = gradient("LimitHub | Fish It", Color3.fromHex("#8ab4f8"), Color3.fromHex("#00ffe1")),
    Size = UDim2.new(0, 480, 0, 300), 
    TabWidth = 120,
    Theme = "LimitHub",    
    Acrylic = false
})
local ConfigLod = "LimitHub/FishIt/config/FishIt.json"


function NotifyHub(text) 
Library:Notify({
Title = "LimitHub", 
Content = text,
Duration = 5,
})
end


local Tabs = {
    Main     = Window:AddTab({ Title = "Main",     Icon = "star" }),
    Player   = Window:AddTab({ Title = "Player",   Icon = "user" }),
    Event    = Window:AddTab({ Title = "Event",    Icon = "eye" }),
    Enchant  = Window:AddTab({ Title = "Enchant",  Icon = "wand" }),
    Trade    = Window:AddTab({ Title = "Trade Option",  Icon = "airplay"}),
    Shop     = Window:AddTab({ Title = "Shop",     Icon = "shopping-cart" }),
    Teleport = Window:AddTab({ Title = "Teleport",  Icon = "map" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "cog" })
}
Window:SelectTab(1)

local Data = {}
-- initialize variable 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
if not player or not replicatedStorage then
    return
end
local lastEventTime = tick()
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local playerGui = player:WaitForChild("PlayerGui")
local Client = require(replicatedStorage.Packages.Replion).Client
local Data = Client:WaitReplion("Data")
local ItemsFolder = replicatedStorage:WaitForChild("Items")
local REFavoriteItem = replicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RE/FavoriteItem"]
local TierUtility = require(replicatedStorage.Shared.TierUtility)
local itemsFolder = replicatedStorage:FindFirstChild("Items")
local net = replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")
local lastEventTime = tick() -- tick() mengembalikan waktu sekarang dalam detik
local inventoryPage = player.PlayerGui.Inventory.Main.Content.Pages.Inventory
local SellAllButton = player.PlayerGui.Inventory.Main.SellAll
local Remotes = {}

Remotes.RF_ChargeFishingRod = net:WaitForChild("RF/ChargeFishingRod")
Remotes.RF_RequestFishingMinigameStarted = net:WaitForChild("RF/RequestFishingMinigameStarted")
Remotes.RE_FishingCompleted = net:WaitForChild("RE/FishingCompleted")
Remotes.RE_EquipTool = net:WaitForChild("RE/EquipToolFromHotbar")
Remotes.UnEquipTool = net:WaitForChild("RE/UnequipToolFromHotbar")
Remotes.RE_FishingEffect = net:WaitForChild("RE/PlayFishingEffect")
Remotes.RF_AutoFish = net:WaitForChild("RF/UpdateAutoFishingState")
Remotes.RE_EquipItem = net:WaitForChild("RE/EquipItem")
Remotes.RF_InitiateTrade = net:WaitForChild("RF/InitiateTrade")
Remotes.RF_AwaitTradeResponse = net:WaitForChild("RF/AwaitTradeResponse")
Remotes.RERollEnchant = net:WaitForChild("RE/RollEnchant")
Remotes.RE_ActivateEnchantingAltar = net:WaitForChild("RE/ActivateEnchantingAltar")
Remotes.RF_CancelFishing = net:WaitForChild("RF/CancelFishingInputs")


-------FUNGSI STARTFISHING---------

local RE_FishingStopped = net:WaitForChild("RE/FishingStopped")

local dapatIkan = true

local fishCount = 0
local fishCountFarm = 0;
local FishingController = require(replicatedStorage:WaitForChild("Controllers"):WaitForChild("FishingController"))
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Variabel global
local StartRodCharge = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild(
    "StartRodCharge")
local RodThrow = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("RodThrow")
local EquipIdle = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("EquipIdle")

local ReelingIdle = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("ReelingIdle")
local EasyFishReelStart = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild(
    "EasyFishReel")
local FishCaught = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("FishCaught")

local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

local StartRodChargeAnim = animator:LoadAnimation(StartRodCharge)
local RodThrowAnim = animator:LoadAnimation(RodThrow)
local ReelingIdleAnim = animator:LoadAnimation(ReelingIdle)
local EasyFishReelStartAnim = animator:LoadAnimation(EasyFishReelStart)
local FishCaughtAnim = animator:LoadAnimation(FishCaught)

local FavoriteToggles = {
    Legendary = false,
    Mythical = false,
    Secret = false
}
local toggleState = {
    AutoSell = false,
    fishingAnimation = false,
    autoBuyWeather = false,
    infJump = false,
    loopDelay = 0.1,
    perfectCast = false,
    amazingCast = false,
    floatingPlatform = false,
    autoFix = false,
    autoFishing = false,
    priceValue = false,
    bool_autoFarm = false,
    AutoSellbp = false,
    lockPosition = false
}

local function getFishInfoById(id)
    for _, itemModule in pairs(ItemsFolder:GetChildren()) do
        if itemModule:IsA("ModuleScript") then
            local ok, data = pcall(require, itemModule)
            if ok and data and data.Data and data.Data.Id == id then
                return data
            end
        end
    end
    return nil
end

-- Fungsi untuk favorite ikan sesuai tier
local function favoriteAll()
    local inv = Data:Get("Inventory")
    if not inv or not inv.Items then
        return
    end

    for _, v in pairs(inv.Items) do
        local itemInfo = getFishInfoById(v.Id)
        if itemInfo and itemInfo.Data.Type == "Fishes" then

            if v.UUID and not v.Favorited then
                REFavoriteItem:FireServer(v.UUID)
            end
        end
    end
end

local function unfavoriteAll()
    local inv = Data:Get("Inventory")
    if not inv or not inv.Items then
        return
    end

    for _, v in pairs(inv.Items) do
        local itemInfo = getFishInfoById(v.Id)
        if itemInfo and itemInfo.Data.Type == "Fishes" then
            if v.UUID and v.Favorited then
                REFavoriteItem:FireServer(v.UUID)
            end
        end
    end
end


-----FUNGSI PLAY ANIMASI ------
local currentTracks = {}
local function playWithDuration(id, duration)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    -- Hentikan semua track sebelum play
    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
        track:Stop()
    end

    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. id

    local track = humanoid:LoadAnimation(anim)
    track:Play()

    -- Stop setelah durasi
    task.delay(duration, function()
        if track.IsPlaying then
            track:Stop()
        end
    end)

    return track
end

local function stopFishing()
    for i = 1, 25 do
        Remotes.RE_FishingCompleted:FireServer()
        task.wait(0.5)
    end
    pcall(function()
        if FishingController and FishingController.RequestClientStopFishing then
            FishingController:RequestClientStopFishing(true)
        end
    end)

end

-- deps
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- flag runner global (biar gampang stop dari luar)
getgenv().__fishingRunner = getgenv().__fishingRunner or { running = false }

local function oneFrame()
    -- yield 1 frame (tanpa delay â€œwaktuâ€); aman biar thread ga kebakar
    RunService.Heartbeat:Wait()
end

local function startFishing(val)
    if val then
        pcall(function()
            local args = {1}
            ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
                :WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
                :WaitForChild("RE/EquipToolFromHotbar"):FireServer(unpack(args))
        end)

        getgenv().__fishingRunner.running = true

        task.spawn(function()
            while getgenv().__fishingRunner.running do
                pcall(function()
                    -- stop semua anim aktif
                    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                        track:Stop()
                    end

                    dapatIkan = true

                    if toggleState.fishingAnimation and StartRodChargeAnim then
                        StartRodChargeAnim:Play()
                    end

                    Remotes.RF_ChargeFishingRod:InvokeServer(Workspace:GetServerTimeNow())
                    if toggleState.fishingAnimation and RodThrowAnim then
                        RodThrowAnim:Play()
                    end

                    local x, y
                    if toggleState.perfectCast and not toggleState.amazingCast then
                        x, y = -0.7499996423721313, 1
                    elseif not toggleState.perfectCast and toggleState.amazingCast then
                        x, y = -139.63796997070312, 0.8769422639492821
                    else
                        x = math.random(-1000, 1000) / 1000
                        y = math.random(0, 1000) / 1000
                    end

                    if toggleState.fishingAnimation then
                        if playWithDuration then
                            playWithDuration("92624107165273", 2)
                            playWithDuration("134965425664034", 15)
                        end
                    end

                    Remotes.RF_RequestFishingMinigameStarted:InvokeServer(x, y)

                    if toggleState.fishingAnimation and EasyFishReelStartAnim then
                        EasyFishReelStartAnim:Play()
                    end

                    local completedArgs = {}
                    while dapatIkan and getgenv().__fishingRunner.running do
                        Remotes.RE_FishingCompleted:FireServer(unpack(completedArgs))
                        oneFrame() 
                    end
                end)

                if toggleState.loopDelay and toggleState.loopDelay > 0 then
                    task.wait(toggleState.loopDelay)
                else
                    oneFrame()
                end
            end
        end)

    else

        getgenv().__fishingRunner.running = false


        pcall(function()
            Remotes.RF_CancelFishing:InvokeServer()
        end)

        pcall(function()
            if FishingController and FishingController.RequestClientStopFishing then
                FishingController:RequestClientStopFishing(true)
            end
        end)


        for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
    end
end


local lockPositionState = {
    enabled = false,
    position = nil
}

local AutoSaveEnabled = true
local LastPosition = {}
-------FUNGSI RESPAWN-----------
local saveFile = "last_position.json"

local function savePosition()

    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        local pos = char.HumanoidRootPart.CFrame
        LastPosition = {pos.X, pos.Y, pos.Z, ({pos:ToOrientation()})[1], ({pos:ToOrientation()})[2],
                        ({pos:ToOrientation()})[3]}
        -- simpan ke file agar tetap ada setelah rejoin
        writefile(saveFile, HttpService:JSONEncode(LastPosition))
    end
end
-- Fungsi untuk restore posisi
local function restorePosition()

    if not AutoSaveEnabled then
        return
    end

    -- baca dari file jika ada
    if isfile(saveFile) then
        local data = HttpService:JSONDecode(readfile(saveFile))
        LastPosition = data
    end

    local saved = LastPosition
    if saved and typeof(saved) == "table" and #saved >= 3 then
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart", 5)

        if hrp then
            task.wait(0.3)
            hrp.CFrame = CFrame.new(saved[1], saved[2], saved[3]) *
                             CFrame.Angles(saved[4] or 0, saved[5] or 0, saved[6] or 0)

        end
    end
end

local function respawnPlayer()

    local character = LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.Health = 0 -- memaksa respawn
    end

    local char = Workspace.Characters:FindFirstChild(LocalPlayer.Name)
    local hrp = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")

end
-------FUNGSI ROD MODIFIER---------
local function antiAfk()

    local vu = game:GetService("VirtualUser")
    Players.LocalPlayer.Idled:Connect(function()
        vu:Button2Down(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
        task.wait(1)
        vu:Button2Up(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
        vu:CaptureController()
        vu:ClickButton2(Vector2.new())
    end)

end
antiAfk()
local function startModifier()

    for _, module in ipairs(itemsFolder:GetChildren()) do
        if module:IsA("ModuleScript") then
            local success, rodData = pcall(require, module)
            if success and type(rodData) == "table" then
                rodData.ClickPower = 9999
                rodData.Resilience = 9999
                rodData.Speed = 100
                rodData.MaxWeight = 1000000
            end
            if success and type(rodData) == "table" and rodData.RollData then

                rodData.RollData.BaseLuck = 9999
                if not rodData.RollData.Frequency then
                    rodData.RollData.Frequency = {}
                end
                rodData.RollData.Frequency.Golden = 100
                rodData.RollData.Frequency.Rainbow = 100

                --  print("Rod:", module.Name, "-> BaseLuck:", rodData.RollData.BaseLuck)
            end
        end
    end

    -- === Modify Baits ===
    local baitsFolder = replicatedStorage:WaitForChild("Baits")

    for _, bait in pairs(baitsFolder:GetChildren()) do
        if bait:IsA("ModuleScript") then
            local success, baitModule = pcall(require, bait)
            if success and baitModule and baitModule.Modifiers then

                if baitModule.Modifiers == nil then
                    baitModule.Modifiers = {}
                end
                baitModule.Modifiers.BaseLuck = 99999

                if baitModule.Modifiers.ShinyMultiplier == nil then
                    baitModule.Modifiers.ShinyMultiplier = 99999
                end
                if baitModule.Modifiers.MutationMultiplier == nil then
                    baitModule.Modifiers.MutationMultiplier = 99999
                end

                -- print("Bait updated:", bait.Name)
            else
                warn("Gagal load bait:", bait.Name)
            end
        end
    end

end

local thresholdbp = 4498
local function obtainedNewFish()

    local bagSize = 0
    local backpackGui = player.PlayerGui:FindFirstChild("Backpack")
    if backpackGui then
        local display = backpackGui:FindFirstChild("Display")
        local inventory = display and display:FindFirstChild("Inventory")
        local bagSizeLabel = inventory and inventory:FindFirstChild("BagSize")

        if bagSizeLabel and bagSizeLabel:IsA("TextLabel") then
            bagSize = bagSizeLabel.Text
            local currentStr = bagSize:match("^(%d+)") -- "3000" 

            local current = tonumber(currentStr)
            if (toggleState.AutoSellbp and current >= thresholdbp) then
                replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
            end
            if current and current >= 4995 then
                replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
            end
        end

    end
end

local function getBagSize()
    local bagSize = 0
    pcall(function()
        local backpackGui = player.PlayerGui:WaitForChild("Backpack", 5)
        if backpackGui then
            local bagSizeLabel = backpackGui:FindFirstChild("Display", true) and
                                     backpackGui.Display:FindFirstChild("Inventory", true) and
                                     backpackGui.Display.Inventory:FindFirstChild("BagSize", true)
            if bagSizeLabel and bagSizeLabel:IsA("TextLabel") then
                local current = bagSizeLabel.Text:match("^(%d+)")
                if current then
                    bagSize = tonumber(current)
                    if (toggleState.AutoSellbp and bagSize >= thresholdbp) then
                        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
                    end

                    if bagSize >= 4998 then
                        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
                    end
                end
            end
        end
    end)
    return bagSize
end

local selectedIslands = {}

-- sell allfish

local totalPrice = 0

-- Fungsi untuk cari module berdasarkan nama ikan ya
local function findItemModule2(fullName)
    local itemsFolder = replicatedStorage:FindFirstChild("Items")
    if not itemsFolder then
        return nil
    end

    local cleanedName = fullName or ""
    -- kita clean dulu namanya biar gak ada mutasina ikut
    cleanedName = cleanedName:gsub("%s*%b()", ""):gsub("^%s*(.-)%s*$", "%1")
    local cleanedLower = string.lower(cleanedName)

    local bestMatch, longest = nil, 0
    for _, mod in ipairs(itemsFolder:GetChildren()) do
        if mod:IsA("ModuleScript") then
            local modNameLower = string.lower(mod.Name)
            if cleanedLower:find(modNameLower, 1, true) then
                if #mod.Name > longest then
                    longest = #mod.Name
                    bestMatch = mod
                end
            end
        end
    end
    -- cek yang paling terdekat
    if bestMatch then

        return bestMatch
    end

    for _, mod in ipairs(itemsFolder:GetChildren()) do
        if mod:IsA("ModuleScript") then
            local ok, mdata = pcall(require, mod)
            if ok and type(mdata) == "table" and mdata.Data and type(mdata.Data.Name) == "string" then
                local modDataName = mdata.Data.Name
                local modClean = modDataName:gsub("%s*%b()", ""):gsub("^%s*(.-)%s*$", "%1")
                if string.lower(modClean) == cleanedLower or string.lower(modDataName) == cleanedLower then

                    return mod
                end
            end
        end
    end

    return nil
end

-- Tambah TextLabel harga di bawah ItemName biar pas
local function addSellPriceLabel(itemFrame, price)
    -- Jangan bikin duplikat kalau sudah ada
    if itemFrame:FindFirstChild("SellPriceLabel") then
        itemFrame.SellPriceLabel.Text = "$ " .. tostring(price)
        return
    end

    local label = Instance.new("TextLabel")
    label.Name = "SellPriceLabel"
    label.Text = "$ " .. tostring(price)
    label.Size = UDim2.new(1, 0, 0, 24) -- lebih besar dari default
    label.Position = UDim2.new(0, 0, 0, itemFrame.ItemName.AbsoluteSize.Y + 2) -- tepat di bawah ItemName
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 215, 0) -- warna emas
    label.Font = Enum.Font.GothamBold
    label.TextScaled = true
    label.Parent = itemFrame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 0, 0)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
    stroke.Parent = label

end

local function updateInventoryLabels()
    totalPrice = 0
    for _, child in ipairs(inventoryPage:GetChildren()) do
        if child:FindFirstChild("ItemName") then
            local itemName = child.ItemName.Text
            local module = findItemModule2(itemName)
            if module then
                local ok, mdata = pcall(require, module)

                if ok and mdata and mdata.Data and mdata.SellPrice then
                    addSellPriceLabel(child, mdata.SellPrice)
                end
                if mdata and mdata.SellPrice and mdata.Data.Type == "Fishes" then
                    totalPrice = totalPrice + mdata.SellPrice
                end
            end
        end
    end

    local player = game:GetService("Players").LocalPlayer
    local inventory = player:WaitForChild("PlayerGui"):WaitForChild("Inventory")
    local main = inventory:WaitForChild("Main")
    local sellAll = main:WaitForChild("SellAll")
    local label = sellAll:WaitForChild("Label")
    label.Text = totalPrice

end

local function getFishInfoById(id)
    for _, itemModule in pairs(ItemsFolder:GetChildren()) do
        if itemModule:IsA("ModuleScript") then
            local ok, data = pcall(require, itemModule)
            if ok and data and data.Data and data.Data.Id == id then
                return data
            end
        end
    end
    return nil
end
if toggleState.priceValue then
    updateInventoryLabels()
end

-- obtainednewfish--
local RemoteFishCaught =
    game:GetService("ReplicatedStorage").Packages._Index["sleitnick_net@0.2.0"].net["RE/ObtainedNewFishNotification"]

RemoteFishCaught.OnClientEvent:Connect(function(...)
    dapatIkan = false
    lastEventTime = tick()
    obtainedNewFish()
    fishCount = fishCount + 1
    fishCountFarm = fishCountFarm + 1
    if (toggleState.AutoSell and fishCount >= threshold) then
        -- Jika auto sell aktif dan jumlah ikan >= threshold, teleport
        fishCount = 0
        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
    end

    if (toggleState.AutoSellbp and getBagSize() >= thresholdbp) then 
        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
    end

    if (toggleState.bool_autoFarm and fishCountFarm >= AutoFarmThreshold) then
        fishCountFarm = 0
        task.wait(0.8)
        TeleportRandom()
    end

    if toggleState.priceValue then
        updateInventoryLabels()
    end

    local args = {...}
    for _, v in ipairs(args) do
        if type(v) == "table" and v.InventoryItem and v.InventoryItem.UUID then
            local uuid = v.InventoryItem.UUID
            local idFish = v.InventoryItem.Id
            local itemInfo = getFishInfoById(idFish)

            if itemInfo and itemInfo.Data.Type == "Fishes" and itemInfo.Probability then
                local tierData = TierUtility.GetTierFromRarity(nil, itemInfo.Probability.Chance)
                if tierData then
                    if tierData.Name == "Legendary" and FavoriteToggles.Legendary then
                        REFavoriteItem:FireServer(uuid)
                    elseif tierData.Name == "Mythic" and FavoriteToggles.Mythical then
                        REFavoriteItem:FireServer(uuid)
                    elseif tierData.Name == "SECRET" and FavoriteToggles.Secret then
                        REFavoriteItem:FireServer(uuid)
                    end
                end
            end
        end
    end

end)



local FishingSec = Tabs.Main:AddSection("Auto Fishing")

FishingSec:AddDropdown("Cast_Mode", {
Title = "Cast Mode",
Description = "Select Mode",
Values = {"Random", "Perfect", "Amazing"}, 
Default = "Random",
Multi = false, 
AllowNull = true, 
Callback = function(option)
        if option == "Perfect" then
            toggleState.perfectCast = true
            toggleState.amazingCast = false

        elseif option == "Amazing" then
            toggleState.amazingCast = true
            toggleState.perfectCast = false

        elseif option == "Random" then
            toggleState.perfectCast = false
            toggleState.amazingCast = false

        end
end
})

Data.AutoMancing = false
local ToggleFS = FishingSec:AddToggle("Auto_Fishing",{
Title = "Auto Fishing",
Description = "Turn on this toggle for auto fish",
Default = false,
Callback = function(value)
        if value then
            if Data.AutoMancing then return end
            Data.AutoMancing = true
            toggleState.autoFishing = true
            startFishing(true)        
        else
            Data.AutoMancing = false
            toggleState.autoFishing = false
            startFishing(false) 
        end
end
})

Data.InstantCatch = false
FishingSec:AddToggle("Instant_Catch",{
Title = "No Animation",
Description = "Turn on this if without Animation",
Default = false,
Callback = function(value)
        if value then
            if Data.InstantCatch then return end
            Data.InstantCatch = true
            toggleState.fishingAnimation = false
            startFishing(true) 
        else
            Data.InstantCatch = false
            toggleState.fishingAnimation = true
            startFishing(true) 
        end
end
})

local freezeConnection = nil
local freezeCFrame = nil
local originalPlatformStand = nil

local freezecok = FishingSec:AddToggle("Freeze Character", {
    Title = "Freeze Character",
    Description = "Freeze your character",
    Default = false,
    Callback = function(Value)
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")

        if Value then
            if freezeConnection then return end -- biar gak dobel

            freezeCFrame = hrp.CFrame
            originalPlatformStand = hum and hum.PlatformStand

            if hum then
                hum.PlatformStand = true
            end
            freezeConnection = RunService.Heartbeat:Connect(function()
                if not hrp or not hrp.Parent then return end
                pcall(function()
                    hrp.AssemblyLinearVelocity = Vector3.zero
                    hrp.AssemblyAngularVelocity = Vector3.zero
                    hrp.Velocity = Vector3.zero
                    hrp.RotVelocity = Vector3.zero
                    hrp.CFrame = freezeCFrame
                end)
            end)

            print("[Freeze] Aktif: posisi dikunci.")
        else
            if freezeConnection then
                freezeConnection:Disconnect()
                freezeConnection = nil
            end

            if hum and originalPlatformStand ~= nil then
                hum.PlatformStand = originalPlatformStand
                originalPlatformStand = nil
            end

            freezeCFrame = nil
        end
    end
})


Data.AutoFixStuck = false
FishingSec:AddToggle("Auto_Fix",{
Title = "Auto Fix Stuck",
Description = "Fishing Stuck",
Default = false,
Callback = function(value)
        if value then
            if Data.FixStuck then return end
            Data.FixStuck = true
            toggleState.autoFix = true
        else
            Data.FixStuck = false
            toggleState.autoFix = false
        end
end
})

task.spawn(function()
    while true do
        task.wait(3)
        local elapsed = tick() - lastEventTime
        if elapsed > 5 and toggleState.autoFishing and toggleState.autoFix then
            ToggleFS:SetValue(false)
            task.wait(1.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/CancelFishingInputs"):InvokeServer()
            task.wait(1.5)
            ToggleFS:SetValue(true)
            NotifyHub("Auto Fixed Stuck Fishing")
            lastEventTime = tick()
        end
    end
end)

--// === Bypass Function ===
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local _loadedFC, _loadedConst = nil, nil

local function applyFishingBypass()
    if not _loadedFC then
        local okFC, FC = pcall(function()
            return require(ReplicatedStorage:WaitForChild("Controllers"):WaitForChild("FishingController"))
        end)
        if okFC and type(FC) == "table" then _loadedFC = FC end
    end

    if not _loadedConst then
        local okConst, Const = pcall(function()
            return require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Constants"))
        end)
        if okConst and type(Const) == "table" then _loadedConst = Const end
    end

    if _loadedConst then
        local old = _loadedConst.FishingCooldownTime
        _loadedConst.FishingCooldownTime = 0.0
        print("[Bypass] From:", tostring(old), "â†’ 0")
    end

    if _loadedFC then
        _loadedFC.OnCooldown = function(...) return false end
        print("[Bypass] âœ…")
    end
end

FishingSec:AddToggle("Vuln_Caught", {
    Title = "Vuln Caught",
    Description = "Bypass fishing cooldown & vulnerability check",
    Default = false,
    Callback = function(value)
        if value then
            print("[Vuln Caught] Applying bypass...")
            applyFishingBypass()
            print("[Vuln Caught] Active âœ…")
        else
            print("[Vuln Caught] Disabled ðŸ§Š")
        end
    end,
})



FishingSec:AddButton({
Title = "Manual Fix Stuck",
Description = "If Stuck Fishing",
Callback = function()
game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/CancelFishingInputs"):InvokeServer()
end
})


local SellSec = Tabs.Main:AddSection("Auto Sell Fish")
Data.AutoMaxBP = false

SellSec:AddInput("Threshold_Sell",{
Title = "Input: Sell Threshold",
Description = "Amount Fish",
Placeholder = "5000",
Numeric = true,
Finished = true,
Callback = function(Value)
thresholdbp = tonumber(Value)
end
})

SellSec:AddToggle("Auto_Sell",{
Title = "Auto Sell Threshold",
Description = "Auto Sell Fish",
Default = false,
Callback = function(value)
if value then
    if Data.AutoMaxBP then return end
    Data.AutoMaxBP = true
    toggleState.AutoSellbp = true
else
    Data.AutoMaxBP = false
    toggleState.AutoSellbp = false
end
end
})

SellSec:AddButton({
Title = "Sell All Fish 1x", 
Callback = function()
replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Net = ReplicatedStorage
    :WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

-- Remotes (pakai nama dengan slash, sesuai struktur game kamu)
local PurchaseBaitRF = PurchaseBaitRF or Net:WaitForChild("RF/PurchaseBait")
local PurchaseRodRF  = PurchaseRodRF  or Net:WaitForChild("RF/PurchaseFishingRod")
local PurchaseBoatRF = PurchaseBoatRF or Net:WaitForChild("RF/PurchaseBoat")
local PurchaseGearRF = PurchaseGearRF or Net:WaitForChild("RF/PurchaseGear")

-- Global state
local G = (getgenv and getgenv()) or _G
G.__SelectedBaitId = G.__SelectedBaitId or nil
G.__SelectedRodId  = G.__SelectedRodId  or nil
G.__SelectedBoatId = G.__SelectedBoatId or nil
G.__SelectedItemId = G.__SelectedItemId or nil


BaitIds = BaitIds or {
    ["Luck Bait"]        = 2,
    ["Midnight Bait"]    = 3,
    ["Nature Bait"]      = 4,
    ["Chroma Bait"]      = 5,
    ["Dark Matter Bait"] = 6,
    ["Corrupt Bait"]     = 7,
    ["Aether Bait"]      = 8,
}
BaitList = BaitList or {
    "Luck Bait","Midnight Bait","Nature Bait","Chroma Bait",
    "Dark Matter Bait","Corrupt Bait","Aether Bait"
}

local BobberSection = Tabs.Shop:AddSection("Bobbers Shop")
BobberSection:AddDropdown("BaitDropdown", {
    Title = "Select: Bait",
    Values = BaitList,
    Default = nil,
    Multi = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and BaitIds[value]
        if id then
            G.__SelectedBaitId = id
            warn(("[Bait] Selected '%s' -> id=%s"):format(value, tostring(id)))
        else
            G.__SelectedBaitId = nil
            warn("[Bait] Unknown selection: " .. tostring(value))
        end
    end
})
BobberSection:AddButton({
    Title = "Buy Selected Bait",
    Callback = function()
        local id = G.__SelectedBaitId
        if not id then return warn("[Bait] Please select a bait first!") end
        local ok, res = pcall(function() return PurchaseBaitRF:InvokeServer(id) end)
        if ok then print("[Bait] Result:", res) else warn("[Bait] Failed:", res) end
    end
})

-- ---------- ROD SHOP ----------
local RodSection = Tabs.Shop:AddSection("Rod Shop")

local RodIds = {
    ["Luck Rod"]      = 79,   -- 350
    ["Carbon Rod"]    = 76,   -- 900
    ["Grass Rod"]     = 85,   -- 1.5K
    ["Demascus Rod"]  = 77,   -- 3K
    ["Ice Rod"]       = 78,   -- 5K
    ["Lucky Rod"]     = 4,    -- 15K
    ["Angler Rod"]    = 168,  -- 8,000K
    ["Ares Rod"]      = 126,  -- 3,000K
    ["Astral Rod"]    = 5,    -- 1,000K
    ["Chrome Rod"]    = 7,    -- 437K  -- <- konsisten
    ["Midnight Rod"]  = 80,   -- 50K
    ["Steampunk Rod"] = 6,    -- 215K
}

local RodList = {
    "Luck Rod","Carbon Rod","Grass Rod","Demascus Rod","Ice Rod","Lucky Rod",
    "Angler Rod","Ares Rod","Astral Rod","Chrome Rod","Midnight Rod","Steampunk Rod" -- <- ganti Pod -> Rod
}

RodSection:AddDropdown("RodDropdown", {
    Title   = "Select Rod",
    Values  = RodList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and RodIds[value]
        if not id then
            G.__SelectedRodId = nil
            warn("[Rod] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedRodId = id
        warn(("[Rod] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})

RodSection:AddButton({
    Title = "Buy Selected Rod",
    Description = "Purchase the rod selected in the dropdown",
    Callback = function()
        local id = G.__SelectedRodId
        if not id then return warn("[Rod] Please select a rod first!") end
        -- Sama seperti contohmu: argumen tunggal angka
        local ok, res = pcall(function() return PurchaseRodRF:InvokeServer(id) end)
        if ok then
            print("[Rod] Result:", res)
        else
            warn("[Rod] Failed:", res)
            -- Kalau masih gagal, coba format alternatif:
            -- local ok2, res2 = pcall(function() return PurchaseRodRF:InvokeServer({id}) end)
            -- print("Alt tbl arg:", ok2, res2)
        end
    end
})

-- ---------- BOAT SHOP ----------
local BoatSection = Tabs.Shop:AddSection("Boat Shop")

local BoatIds = {
    ["Small Boat"]     = 1, -- 300
    ["Kayak"]          = 2, -- 1.1k
    ["Jetski"]         = 3, -- 7.5k
    ["Highfield Boat"] = 4, -- 25k
    ["Speed Boat"]     = 5, -- 70k
    ["Fishing Boat"]   = 6, -- 180k
    ["Mini Yacht"]     = 7, -- 1.20m
}
local BoatList = {"Small Boat","Kayak","Jetski","Highfield Boat","Speed Boat","Fishing Boat","Mini Yacht"}

BoatSection:AddDropdown("BoatDropdown", {
    Title   = "Select Boat",
    Values  = BoatList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and BoatIds[value]
        if not id then
            G.__SelectedBoatId = nil
            warn("[Boat] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedBoatId = id
        warn(("[Boat] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})
BoatSection:AddButton({
    Title = "Buy Selected Boat",
    Callback = function()
        local id = G.__SelectedBoatId
        if not id then return warn("[Boat] Please select a boat first!") end
        local ok, res = pcall(function() return PurchaseBoatRF:InvokeServer(id) end)
        if ok then print("[Boat] Result:", res) else warn("[Boat] Failed:", res) end
    end
})

local ItemsSection = Tabs.Shop:AddSection("Items Shop")
local ItemIds = { ["Diving Gear"] = 105, ["Fishing Radar"] = 81 }
local ItemList = { "Diving Gear", "Fishing Radar" }

ItemsSection:AddDropdown("ItemDropdown", {
    Title   = "Select Item",
    Values  = ItemList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and ItemIds[value]
        if not id then
            G.__SelectedItemId = nil
            warn("[Item] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedItemId = id
        warn(("[Item] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})
ItemsSection:AddButton({
    Title = "Buy Selected Item",
    Callback = function()
        local id = G.__SelectedItemId
        if not id then return warn("[Item] Please select an item first!") end
        local ok, res = pcall(function() return PurchaseGearRF:InvokeServer(id) end)
        if ok then print("[Item] Result:", res) else warn("[Item] Failed:", res) end
    end
})

local WeatherSection = Tabs.Shop:AddSection("Weather Shop")

local __autoWeatherOn = false
local __selectedWeathers = {}

local function _normW(s)
    return (tostring(s or ""):gsub("^%s+",""):gsub("%s+$",""):lower())
end
local WeatherAlias = { ["strom"] = "Storm" }

local function __purchaseWeather(preset)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local ok, res = pcall(function()
        local canon = WeatherAlias[_normW(preset)] or preset
        local args = { tostring(canon or "Wind") }
        local rf = ReplicatedStorage
            :WaitForChild("Packages")
            :WaitForChild("_Index")
            :WaitForChild("sleitnick_net@0.2.0")
            :WaitForChild("net")
            :WaitForChild("RF/PurchaseWeatherEvent")
        return rf:InvokeServer(unpack(args))
    end)
    if not ok then warn("[Weather] Invoke failed:", res) end
    return ok, res
end

local function __purchaseAll(list)
    for _, w in ipairs(list) do __purchaseWeather(w) end
end

task.spawn(function()
    while task.wait(10) do
        if __autoWeatherOn and #__selectedWeathers > 0 then
            __purchaseAll(__selectedWeathers)
        end
    end
end)

local WeatherValues = {
    Wind    = "Wind",
    Cloudy  = "Cloudy",
    Snow    = "Snow",
    Strom   = "Strom",
    Radiant = "Radiant",
    ["Shark Hunt"] = "Shark Hunt",
}

WeatherSection:AddDropdown("WeatherChoice", {
    Title = "Weather Preset",
    Values = WeatherValues,
    Multi  = true,
    Default = {},
    Callback = function(valMap)
        __selectedWeathers = {}
        if type(valMap) == "table" then
            for label, chosen in pairs(valMap) do
                if chosen then table.insert(__selectedWeathers, tostring(label)) end
            end
        elseif type(valMap) == "string" then
            __selectedWeathers = { valMap }
        end
    end
})

WeatherSection:AddToggle("AutoWeatherToggle", {
    Title = "Auto Weather",
    Description = "Auto purchase selected weather",
    Default = false,
    Callback = function(state)
        __autoWeatherOn = state and true or false
        if __autoWeatherOn and #__selectedWeathers > 0 then
            __purchaseAll(__selectedWeathers)
        end
    end
})

local Movement = {
    SpeedEnabled   = false,
    SpeedValue     = 100,
    InfJump        = false,
    NoClip         = false,
}

local Sec_Movement = Tabs.Player:AddSection("Movement")

Sec_Movement:AddToggle("LH_Speed", {
    Title = "Enable WalkSpeed",
    Default = false,
    Callback = function(on)
        Movement.SpeedEnabled = on
        pcall(function()
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hum  = char:FindFirstChildOfClass("Humanoid")
            if hum then hum.WalkSpeed = on and Movement.SpeedValue or 16 end
        end)
    end
})

Sec_Movement:AddSlider("LH_SpeedVal", {
    Title = "WalkSpeed Value",
    Description = "Adjust your walk speed",
    Default = 100,
    Min = 16,
    Max = 200,
    Rounding = 0,
    Callback = function(v)
        Movement.SpeedValue = v
        if Movement.SpeedEnabled then
            pcall(function()
                local char = LocalPlayer.Character
                local hum  = char and char:FindFirstChildOfClass("Humanoid")
                if hum then hum.WalkSpeed = v end
            end)
        end
    end
})

Sec_Movement:AddToggle("LH_InfJump", {
    Title = "Enable Infinite Jump",
    Default = false,
    Callback = function(on)
        Movement.InfJump = on
    end
})

Sec_Movement:AddToggle("LH_NoClip", {
    Title = "Enable NoClip",
    Default = false,
    Callback = function(on)
        Movement.NoClip = on
        if not on then
            pcall(function()
                local char = LocalPlayer.Character
                if char then
                    for _, p in ipairs(char:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = true end
                    end
                end
            end)
        end
    end
})

-- Infinite Jump
pcall(function()
    game:GetService("UserInputService").JumpRequest:Connect(function()
        if Movement.InfJump then
            local char = LocalPlayer.Character
            local hum  = char and char:FindFirstChildOfClass("Humanoid")
            if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
        end
    end)
end)


RunService.Stepped:Connect(function()
    if Movement.NoClip then
        local char = LocalPlayer.Character
        if char then
            for _, p in ipairs(char:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = false end
            end
        end
    end
end)


LocalPlayer.CharacterAdded:Connect(function(char)
    if Movement.SpeedEnabled then
        local hum = char:WaitForChild("Humanoid", 5)
        if hum then hum.WalkSpeed = Movement.SpeedValue end
    end
end)

-- ===== Services =====
local Players     = game:GetService("Players")
local Workspace   = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

getgenv().eventSet = getgenv().eventSet or {
    enabled          = false,
    selectedEvents   = {},   -- selalu disimpan sbg array hasil normalisasi
    originalPosition = nil,
    platform         = nil,
    isAtEvent        = false
}

local EventSection = Tabs.Event:AddSection("Auto Event")

getgenv().eventNames = {
    "Megalodon Hunt", "Admin Event", "Ghost Worm", "Worm Hunt",
    "Shark Hunt", "Ghost Shark Hunt", "Shocked", "Black Hole", "Meteor Rain"
}

-- helper: normalisasi value dropdown (array/string/dictionary -> array)
local function normalizeSelection(value)
    local out = {}
    if type(value) == "table" then
        local hasBool = false
        for _, v in pairs(value) do
            if type(v) == "boolean" then hasBool = true break end
        end
        if hasBool then
            -- dictionary boolean
            for name, enabled in pairs(value) do
                if enabled then table.insert(out, tostring(name)) end
            end
        else
            -- array
            for _, name in ipairs(value) do
                table.insert(out, tostring(name))
            end
        end
    elseif type(value) == "string" then
        out = { value }
    end
    return out
end

EventSection:AddDropdown("AE_SelectEvents", {
    Title     = "Select Events",
    Values    = getgenv().eventNames,
    AllowNone = true,
    Multi     = true,
    Default   = {}, -- jangan auto pilih
    Callback  = function(value)
        getgenv().eventSet.selectedEvents = normalizeSelection(value)
    end
})

EventSection:AddToggle("AE_AutoEvent", {
    Title   = "Auto Event",
    Desc    = "Automatically teleports you to the chosen spawned event.",
    Value   = false,
    Callback = function(value)
        local S = getgenv().eventSet
        S.enabled = value
        if not value and S.isAtEvent then
            local char = LocalPlayer.Character
                or (Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild(LocalPlayer.Name))
            local hrp  = char and char:FindFirstChild("HumanoidRootPart")
            if hrp and S.originalPosition then
                if hrp.Anchored then hrp.Anchored = false; task.wait(0.05) end
                hrp.CFrame = S.originalPosition
                pcall(function()
                    if lockPositionState and lockPositionState.enabled then
                        lockPositionState.position = hrp.CFrame
                    end
                end)
            end
            S.isAtEvent = false
        end
    end
})

-- ===== Finder =====
local function findEventPart(eventName)
    local menuRings = Workspace:FindFirstChild("!!! MENU RINGS")
    if not menuRings then return nil end

    local eventNameLower = eventName:lower()
    for _, propsFolder in ipairs(menuRings:GetChildren()) do
        if propsFolder.Name == "Props" then
            for _, child in ipairs(propsFolder:GetChildren()) do
                if child.Name:lower() == eventNameLower then
                    if child:IsA("Model") then
                        local part = child.PrimaryPart or child:FindFirstChildWhichIsA("BasePart")
                        if part then return part end
                    elseif child:IsA("BasePart") then
                        return child
                    end
                end
                for _, descendant in ipairs(child:GetDescendants()) do
                    if descendant:IsA("TextLabel") and descendant.Text:lower() == eventNameLower then
                        local a = descendant
                        while a and a ~= propsFolder do
                            if a:IsA("BasePart") then return a end
                            a = a.Parent
                        end
                    end
                end
            end
        end
    end
    return nil
end

-- ===== Worker =====
task.spawn(function()
    while task.wait(5) do
        local S = getgenv().eventSet
        if not S.enabled then continue end

        -- pastikan selectedEvents selalu array
        if type(S.selectedEvents) ~= "table" then
            S.selectedEvents = {}
        end
        -- guard kosong
        if #S.selectedEvents == 0 then continue end

        local char = (Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild(LocalPlayer.Name))
                    or LocalPlayer.Character
        local hrp  = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local eventPart = nil
        for _, selectedEvent in ipairs(S.selectedEvents) do
            local part = findEventPart(selectedEvent)
            if part then eventPart = part; break end
        end

        if eventPart and not S.isAtEvent then
            S.isAtEvent = true
            S.originalPosition = hrp.CFrame

            pcall(function() if floatPlat then floatPlat(true) end end)
            pcall(function() if FloatPlayer and FloatPlayer.Set then FloatPlayer:Set(true) end end)

            if hrp.Anchored then hrp.Anchored = false end
            hrp.CFrame = eventPart.CFrame * CFrame.new(0, 3, 0)

            pcall(function()
                if lockPositionState and lockPositionState.enabled then
                    lockPositionState.position = hrp.CFrame
                end
            end)

        elseif (not eventPart) and S.isAtEvent then
            pcall(function() if floatPlat then floatPlat(false) end end)
            pcall(function() if FloatPlayer and FloatPlayer.Set then FloatPlayer:Set(false) end end)

            if S.originalPosition then
                if hrp.Anchored then hrp.Anchored = false end
                hrp.CFrame = S.originalPosition
                pcall(function()
                    if lockPositionState and lockPositionState.enabled then
                        lockPositionState.position = hrp.CFrame
                    end
                end)
            end
            S.isAtEvent = false
        end
    end
end)


local IslandsSection = Tabs.Teleport:AddSection("Islands Teleport")
local islandCoordsList = {
    ["01"] = { name = "Crater Island", position = Vector3.new(1014.896, 20.921, 5071.434) },
    ["02"] = { name = "Treasure Room", position = Vector3.new(-3598.539, -279.646, -1634.287) },
    ["03"] = { name = "Lost Shore", position = Vector3.new(-3677, 107, -912) },
    ["04"] = { name = "Fisherman Island", position = Vector3.new(-2.382, 4.5, 2839.47) },
    ["05"] = { name = "Tropical Grove", position = Vector3.new(-2051.413, 6.268, 3662) },
    ["06"] = { name = "Esoteric Depths", position = Vector3.new(3209.068, -1302.855, 1411.844) },
    ["07"] = { name = "Esoteric Island", position = Vector3.new(2031.415, 27.397, 1394.621) },
    ["08"] = { name = "Kohana", position = Vector3.new(-678.811, 4.935, 708.578) },
    ["09"] = { name = "Kohana Volcano", position = Vector3.new(-516.92, 22, 191) },
    ["10"] = { name = "Sisyphus", position = Vector3.new(-3667.556, -135.574, -900.99) },
    ["11"] = { name = "Weather Machine", position = Vector3.new(-1471, -3, 1929) },
    ["12"] = { name = "Winter Fest", position = Vector3.new(1611, 4, 3280) },
    ["13"] = { name = "Coral Reefs", position = Vector3.new(-2949.694, 63.25, 2248.52) }
}
for _, data in pairs(islandCoordsList) do
    IslandsSection:AddButton({
        Title = data.name, Description = "Teleport to " .. data.name,
        Callback = function()
            pcall(function()
                local charFolder = workspace:WaitForChild("Characters", 5)
                local char = charFolder:FindFirstChild(LocalPlayer.Name); if not char then error("Character not found") end
                local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 3)
                if not hrp then error("HumanoidRootPart not found") end
                hrp.CFrame = CFrame.new(data.position + Vector3.new(0,5,0))
            end)
        end
    })
end
-- ================= TELEPORT TO PLAYER (DisplayName) =================
local TPPlayerSection = Tabs.Teleport:AddSection("Teleport to Player")

local SelectedPlayer = nil
local PlayerDropdown
local DisplayNameToUser = {} -- mapping DisplayName -> Username

local function RefreshPlayerList()
    local displayNames = {}
    DisplayNameToUser = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            table.insert(displayNames, p.DisplayName)
            DisplayNameToUser[p.DisplayName] = p.Name
        end
    end
    if PlayerDropdown then
        TPPlayerSection:Remove(PlayerDropdown)
    end
    PlayerDropdown = TPPlayerSection:AddDropdown("PlayerListDropdown", {
        Title = "Select Player",
        Values = displayNames,
        Default = nil,
        Multi = false,
        Callback = function(value)
            SelectedPlayer = value
        end
    })
end

-- ==== STATE ====
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local PlayerList = {}        
local DisplayNameToUser = {}    
local SelectedPlayer = nil    

local PlayerDropdown 

-- ==== UTIL ====
local function getMyHRP()
    local charFolder = workspace:FindFirstChild("Characters")
    local char = (charFolder and charFolder:FindFirstChild(LocalPlayer.Name))
              or LocalPlayer.Character
              or LocalPlayer.CharacterAdded:Wait()
    return char and char:FindFirstChild("HumanoidRootPart")
end

-- ==== REFRESH LIST TANPA :Remove() ====
local function RefreshPlayerList()
    -- kosongkan dengan cara yang benar
    if table.clear then
        table.clear(PlayerList)
        table.clear(DisplayNameToUser)
    else
        -- fallback kalau environment gak punya table.clear
        for k in pairs(PlayerList) do PlayerList[k] = nil end
        for k in pairs(DisplayNameToUser) do DisplayNameToUser[k] = nil end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        -- bikin label yang unik & enak dibaca
        local label = string.format("%s (@%s)", p.DisplayName or p.Name, p.Name)
        table.insert(PlayerList, label)
        DisplayNameToUser[label] = p.Name
    end

    -- update dropdown kalau ada
    if PlayerDropdown then
        pcall(function()
            if PlayerDropdown.SetValues then
                PlayerDropdown:SetValues(PlayerList)
            end
            -- reset selection kalau player sebelumnya udah gak ada
            if SelectedPlayer and not DisplayNameToUser[SelectedPlayer] then
                SelectedPlayer = nil
                if PlayerDropdown.SetValue then
                    PlayerDropdown:SetValue(nil)
                end
            end
        end)
    end
end


RefreshPlayerList()
Players.PlayerAdded:Connect(RefreshPlayerList)
Players.PlayerRemoving:Connect(RefreshPlayerList)

PlayerDropdown = TPPlayerSection:AddDropdown("SelectTPPlayer", {
    Title    = "Select Player",
    Values   = PlayerList,
    Multi    = false,
    Default  = 1,
    Callback = function(choice)
        SelectedPlayer = choice
    end
})

TPPlayerSection:AddButton({
    Title = "Teleport to the Player!",
    Description = "Teleport to selected player",
    Callback = function()
        if not SelectedPlayer then
            if typeof(NotifyHub) == "function" then NotifyHub("Please select a player first!") end
            return
        end
        local username = DisplayNameToUser[SelectedPlayer]
        local target   = username and Players:FindFirstChild(username)

        if target and target.Character then
            local hrpTarget = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP     = getMyHRP()
            if hrpTarget and myHRP then
                myHRP.CFrame = hrpTarget.CFrame + Vector3.new(0, 3, 0)
                if typeof(NotifyHub) == "function" then NotifyHub("Teleported to "..SelectedPlayer) end
                return
            end
        end
        if typeof(NotifyHub) == "function" then NotifyHub("Target player not found!") end
    end
})

local NPCSection = Tabs.Teleport:AddSection("NPC Teleport")
local npcFolder = ReplicatedStorage:WaitForChild("NPC")
for _, npc in pairs(npcFolder:GetChildren()) do
    if npc:IsA("Model") then
        local hrp = npc:FindFirstChild("HumanoidRootPart") or npc.PrimaryPart
        if hrp then
            NPCSection:AddButton({
                Title = npc.Name, Description = "Teleport to " .. npc.Name,
                Callback = function()
                    local charFolder = workspace:FindFirstChild("Characters", 5)
                    local char = charFolder and charFolder:FindFirstChild(LocalPlayer.Name)
                    if not char then return end
                    local myHRP = char:FindFirstChild("HumanoidRootPart")
                    if myHRP then myHRP.CFrame = hrp.CFrame + Vector3.new(0,3,0) end
                end
            })
        end
    end
end



local autoEnchantState = { enabled = false, targetEnchant = nil, stonesUsed = 0 }

local function getEnchantmentList()
    local enchants = {}
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name then
                table.insert(enchants, data.Data.Name)
            end
        end
    end
    table.sort(enchants)
    return enchants
end

local function getTargetEnchantData(enchantName)
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name == enchantName then
                return data
            end
        end
    end
    return nil
end


local EnchantSection = Tabs.Enchant:AddSection("Auto Enchantment")

-- ====== STATE & HELPERS ======
local autoEnchantState = { enabled = false, targetEnchant = nil, stonesUsed = 0 }

local function getEnchantmentList()
    local enchants = {}
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name then
                table.insert(enchants, data.Data.Name)
            end
        end
    end
    table.sort(enchants)
    return enchants
end

-- ====== UI: Dropdown target enchant (single-select) ======
EnchantSection:AddDropdown("LH_TargetEnchant_SEL", {
    Title   = "Select Target",
    Values  = getEnchantmentList(),
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        autoEnchantState.targetEnchant = value
        if value then
            NotifyHub("Target enchant: " .. tostring(value), 2)
        end
    end
})

EnchantSection:AddToggle("LH_AutoEnchant_TOGGLE", {
    Title   = "Enable Auto Enchant",
    Default = false,
    Callback = function(value)
        autoEnchantState.enabled = value

        if not value then
            NotifyHub("Auto Enchant stopped.", 2)
            return
        end

        task.spawn(function()
            if not autoEnchantState.targetEnchant then
                NotifyHub("Select target enchant first.", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                end)
                return
            end

            -- Teleport ke altar (sesuai source kamu)
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp  = char and char:WaitForChild("HumanoidRootPart", 10)
            if hrp then
                hrp.CFrame = CFrame.new(3234, -1300, 1401)
                task.wait(2)
            end

            -- Require modul (pcall biar aman)
            local okU, localItemUtility   = pcall(require, replicatedStorage.Shared.ItemUtility)
            local okR, localReplion       = pcall(require, replicatedStorage.Packages.Replion)
            if not (okU and okR) then
                NotifyHub("âŒ Module missing: ItemUtility/Replion", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                end)
                return
            end

            -- Remotes (nama dengan slash, sesuai pola game kamu)
            local okN, netFolder = pcall(function()
                return replicatedStorage.Packages["_Index"]["sleitnick_net@0.2.0"].net
            end)
            if not okN or not netFolder then
                NotifyHub("âŒ Net folder not found.", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                end)
                return
            end

            local equipItemEvent           = netFolder["RE/EquipItem"]
            local equipToolFromHotbarEvent = netFolder["RE/EquipToolFromHotbar"]
            local activateEnchantAltarEvent= netFolder["RE/ActivateEnchantingAltar"]

            local function getEquippedRod()
                local DataReplion   = localReplion.Client:WaitReplion("Data")
                local equippedItems = DataReplion:Get("EquippedItems")
                if not (equippedItems and equippedItems[1]) then return nil, nil end
                local rodUUID       = equippedItems[1]
                local inventoryRods = DataReplion:Get({"Inventory", "Fishing Rods"})
                if not inventoryRods then return nil, nil end
                for _, item in ipairs(inventoryRods) do
                    if item.UUID == rodUUID then
                        local itemData = localItemUtility:GetItemData(item.Id)
                        if itemData and itemData.Data and itemData.Data.Type == "Fishing Rods" then
                            return item, itemData
                        end
                    end
                end
                return nil, nil
            end

            local function findFirstEnchantStone()
                local DataReplion    = localReplion.Client:WaitReplion("Data")
                local inventoryItems = DataReplion:Get({"Inventory", "Items"})
                if inventoryItems then
                    for _, itemData in ipairs(inventoryItems) do
                        local baseItemData = localItemUtility:GetItemData(itemData.Id)
                        if baseItemData and baseItemData.Data and baseItemData.Data.Type == "EnchantStones" then
                            return itemData.UUID, (itemData.Quantity or 1)
                        end
                    end
                end
                return nil, 0
            end

            local function findStoneInHotbar()
                local DataReplion   = localReplion.Client:WaitReplion("Data")
                local equippedItems = DataReplion:Get("EquippedItems")
                if equippedItems then
                    local invItems = DataReplion:Get({"Inventory", "Items"})
                    for slot, uuid in ipairs(equippedItems) do
                        if invItems then
                            for _, itemData in ipairs(invItems) do
                                if itemData.UUID == uuid then
                                    local baseData = localItemUtility:GetItemData(itemData.Id)
                                    if baseData and baseData.Data and baseData.Data.Type == "EnchantStones" then
                                        return slot
                                    end
                                end
                            end
                        end
                    end
                end
                return nil
            end

            autoEnchantState.stonesUsed = 0
            NotifyHub("Auto Enchant started for: " .. tostring(autoEnchantState.targetEnchant), 3)

            while autoEnchantState.enabled do
                local equippedRod, equippedRodData = getEquippedRod()
                if not equippedRod then
                    NotifyHub("Checking..", 3)
                    autoEnchantState.enabled = false
                    pcall(function()
                        if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                        if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                        if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                    end)
                    break
                end

                local currentEnchantName = "None"
                if equippedRod.Metadata and equippedRod.Metadata.EnchantId then
                    local okE, currentEnchantData = pcall(localItemUtility.GetEnchantData, localItemUtility, equippedRod.Metadata.EnchantId)
                    if okE and currentEnchantData and currentEnchantData.Data then
                        currentEnchantName = currentEnchantData.Data.Name or "Unknown"
                        if currentEnchantName == autoEnchantState.targetEnchant then
                            NotifyHub(("âœ… Success! '%s' found after %d stones."):format(
                                autoEnchantState.targetEnchant, autoEnchantState.stonesUsed
                            ), 4)
                            autoEnchantState.enabled = false
                            pcall(function()
                                if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                                if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                                if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                            end)
                            pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, 1)
                            break
                        end
                    end
                end

                local stoneUUID, stoneCount = findFirstEnchantStone()
                if not stoneUUID or stoneCount == 0 then
                    NotifyHub("Waiting Enchant Stones...", 2)
                    task.wait(5)
                    continue
                end

                local stoneHotbarSlot = findStoneInHotbar()
                if not stoneHotbarSlot then
                    pcall(equipItemEvent.FireServer, equipItemEvent, stoneUUID, "EnchantStones")
                    task.wait(0.5)
                    stoneHotbarSlot = findStoneInHotbar()
                    if not stoneHotbarSlot then
                        NotifyHub("âŒ Failed equip stone to hotbar.", 3)
                        task.wait(5)
                        continue
                    end
                end

                autoEnchantState.stonesUsed += 1
                NotifyHub(("ðŸ” Enchant attempt... stones used: %d"):format(autoEnchantState.stonesUsed), 1.5)

                pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, stoneHotbarSlot)
                task.wait(0.2)
                pcall(activateEnchantAltarEvent.FireServer, activateEnchantAltarEvent)
                task.wait(2)
                pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, 1)
                task.wait(1)
            end
        end)
    end
})

local AutoFavSection = Tabs.Main:AddSection("Auto Favorite")

-- Safe require helpers
local function safeRequire(pathArray)
    local inst = ReplicatedStorage
    for _,name in ipairs(pathArray) do
        inst = inst:FindFirstChild(name)
        if not inst then return nil end
    end
    if not inst:IsA("ModuleScript") then return nil end
    local ok, mod = pcall(require, inst)
    if ok then return mod end
    return nil
end

-- Try require core modules (do not crash if missing)
local TierUtility       = safeRequire({"Shared","TierUtility"})
local ItemUtility       = safeRequire({"Shared","ItemUtility"})
local ItemStringUtility = safeRequire({"Shared","ItemStringUtility"})

-- Try find Replion safely (global or from Packages/_Index)
local Replion = rawget(_G,"Replion") or (getgenv and getgenv().Replion) or nil
if not Replion then
    local idx = ReplicatedStorage:FindFirstChild("Packages")
                 and ReplicatedStorage.Packages:FindFirstChild("_Index")
    if idx then
        for _, folder in ipairs(idx:GetChildren()) do
            local repl = folder:FindFirstChild("replion") or folder:FindFirstChild("Replion")
            if repl and repl:IsA("ModuleScript") then
                local ok, mod = pcall(require, repl)
                if ok then Replion = mod break end
            end
        end
    end
end


local net2 = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
local REFavoriteItem = net2:WaitForChild("RE/FavoriteItem")

local FavState = {
    enabled = false,
    selected = {},  
    lastRunAt = 0,
    interval = 6,
}

local RarityDropdownValues = {
    Common     = "Common",
    Uncommon   = "Uncommon",
    Rare       = "Rare",
    Epic       = "Epic",
    Legendary  = "Legendary",
    Mythic     = "Mythic",
    Secret     = "Secret",
}
local function _lw(s) return (tostring(s or ""):lower()) end

local function getTierNameFromItemId(itemId)
    if not ItemUtility then return nil end
    local baseItem = ItemUtility:GetItemData(itemId)
    if not baseItem then return nil end

    local data = baseItem.Data or baseItem.data or baseItem
    local chance = data and data.Probability and tonumber(data.Probability.Chance) or nil

    if chance and TierUtility and TierUtility.GetTierFromRarity then
        local td = TierUtility.GetTierFromRarity(nil, chance)
        if td and td.Name then return tostring(td.Name) end
    end

    local TierMap2 = {
        [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Epic",
        [5]="Legendary",[6]="Mythic",[7]="Secret",
    }
    if data and data.Tier and TierMap2[data.Tier] then
        return TierMap2[data.Tier]
    end
    return nil
end

local function favoriteBySelectedRarities()
    if not Replion then return 0, "Replion module not found" end

    local DataReplion = Replion.Client and Replion.Client:WaitReplion("Data")
    if not DataReplion then return 0, "Data replion not available" end

    local invWrap = DataReplion:Get({"Inventory"})
    if not invWrap or not invWrap.Items then return 0 end

    local count = 0
    for _, v in pairs(invWrap.Items) do
        if not v.Favorited and v.Id then
            local tierName = getTierNameFromItemId(v.Id)
            if tierName and FavState.selected[_lw(tierName)] then
                if v.UUID then
                    pcall(function() REFavoriteItem:FireServer(v.UUID) end)
                    count += 1
                end
            end
        end
    end
    return count
end

AutoFavSection:AddDropdown("FavRarityDropdown", {
    Title = "Choose Rarities to Favorite",
    Description = "Auto favorite fish by rarity",
    Values = RarityDropdownValues,
    Default = {},
    Multi = true,
    Callback = function(map)
        FavState.selected = {}
        if type(map) == "table" then
            for label, chosen in pairs(map) do
                if chosen then FavState.selected[_lw(label)] = true end
            end
        end
    end
})

AutoFavSection:AddToggle("FavRarityToggle", {
    Title = "Enable Auto Favorite",
    Description = "Periodically favorites items of chosen rarities",
    Default = false,
    Callback = function(on)
        FavState.enabled = not not on
        if FavState.enabled then
            local n, err = favoriteBySelectedRarities()
            if err and NotifyHub then
                NotifyHub("Auto Favorite warning: "..tostring(err))
            elseif (n or 0) > 0 and NotifyHub then
                NotifyHub(("Favorited %d items (initial)"):format(n))
            end
        end
    end
})


task.spawn(function()
    while true do
        task.wait(1)
        if FavState.enabled then
            local now = os.clock()
            if now - (FavState.lastRunAt or 0) >= FavState.interval then
                FavState.lastRunAt = now
                local _, err = favoriteBySelectedRarities()
                if err and NotifyHub then
                    NotifyHub("Auto Favorite warning: "..tostring(err))
                end
            end
        end
    end
end)

AutoFavSection:AddToggle("UnFavAllRarity", {
    Title = "Auto UnFavorite All",
    Description = "Unfavorite All Fish",
    Default = false,
    Callback = function()
       unfavoriteAll()
    end
})


AutoFavSection:AddToggle("FavAllRarity", {
    Title = "Auto Favorite All",
    Description = "Favorite All Fish",
    Default = false,
    Callback = function()
        favoriteAll()
    end
})

local SettingsSection = Tabs.Settings:AddSection("Performance & Server")
SettingsSection:AddButton({
    Title = "Boost FPS (Maximize Performance)",
    Description = "Optimize game for better FPS",
    Callback = function()
        for _, v in pairs(game:GetDescendants()) do
            if v:IsA("BasePart") then v.Material = Enum.Material.SmoothPlastic v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then v.Transparency = 1 end
        end
        local Lighting = game:GetService("Lighting")
        for _, effect in pairs(Lighting:GetChildren()) do if effect:IsA("PostEffect") then effect.Enabled = false end end
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1e10
        settings().Rendering.QualityLevel = "Level01"
    end
})

local TeleportService = game:GetService("TeleportService")
local function Rejoin() local p = Players.LocalPlayer; if p then TeleportService:Teleport(game.PlaceId, p) end end
local function ServerHop()
    local placeId, servers, cursor = game.PlaceId, {}, ""
    repeat
        local url = "https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100" .. (cursor~="" and ("&cursor="..cursor) or "")
        local ok, result = pcall(function() return HttpService:JSONDecode(game:HttpGet(url)) end)
        if ok and result and result.data then
            for _, server in pairs(result.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    table.insert(servers, server.id)
                end
            end
            cursor = result.nextPageCursor or ""
        else break end
    until not cursor or #servers > 0
    if #servers > 0 then TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(1,#servers)], LocalPlayer) end
end

local WebhookState = { url = "", enabled = false }

local WebhookTab     = Window:AddTab({ Title = "Webhook", Icon = "link" })
local WebhookSection = WebhookTab:AddSection("Webhook Option")

WebhookSection:AddInput("WebhookURL", {
    Title = "Webhook URL",
    Description = "",
    Placeholder = "You webhook link here!",
    Default = "",
    Callback = function(text)
        WebhookState.url = tostring(text or "")
    end
})

-- ====== Filter Rarity utk Webhook (fix multi-select) ======
WebhookState.rarityFilter = {}
WebhookState._raritySet   = {}

local function _normR(s) return (tostring(s or ""):gsub("^%s+",""):gsub("%s+$",""):lower()) end

-- IMPORTANT for Multi=true: Values harus dictionary label->string
local RarityValues = {
    Common     = "Common",
    Uncommon   = "Uncommon",
    Rare       = "Rare",
    Epic       = "Epic",
    Legendary  = "Legendary",
    Mythic     = "Mythic",
    Secret     = "Secret",
}

local function _rebuildRaritySet(vals)
    for k in pairs(WebhookState._raritySet) do WebhookState._raritySet[k] = nil end
    table.clear(WebhookState.rarityFilter)
    if type(vals) ~= "table" then return end

    -- terima dua bentuk: map {Common=true,...} atau array {"Common","Rare",...}
    local hasNumeric = false
    for k,_ in pairs(vals) do if typeof(k) == "number" then hasNumeric = true break end end

    if hasNumeric then
        for _,v in ipairs(vals) do
            local key = _normR(v)
            if key ~= "" then
                WebhookState._raritySet[key] = true
                table.insert(WebhookState.rarityFilter, v)
            end
        end
    else
        for k,v in pairs(vals) do
            if v then
                local key = _normR(k)
                if key ~= "" then
                    WebhookState._raritySet[key] = true
                    table.insert(WebhookState.rarityFilter, k)
                end
            end
        end
    end
end

WebhookSection:AddDropdown("RarityWebhook", {
    Title = "Choose Rarity Webhook",
    Description = "Only show rarity you want (empty = all)",
    Values = RarityValues,  -- dictionary label->string (AMAN untuk Multi=true)
    Default = {},           -- kosongkan default agar tidak kirim string ke loader
    Multi = true,
    Callback = function(vals)
        _rebuildRaritySet(vals)
    end
})

WebhookSection:AddToggle("WebhookToggle", {
    Title = "Enable Webhook",
    Description = "Send Webhook that fish you caught!",
    Default = false,
    Callback = function(on)
        WebhookState.enabled = on and true or false
    end
})

local function sendWebhook(message, state)
    state = state or WebhookState
    local msg = tostring(message or "")
    if not (state.enabled and type(state.url) == "string" and #state.url > 0) then return end
    local req = (syn and syn.request) or (http and http.request) or http_request or request
    if not req then return end
    pcall(function()
        req({
            Url = state.url, Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode({ content = msg })
        })
    end)
end

local function sendWebhookEmbed(title, fields, state)
    state = state or WebhookState
    if not (state.enabled and type(state.url) == "string" and #state.url > 0) then return end
    local req = (syn and syn.request) or (http and http.request) or http_request or request
    if not req then return end
    local embed = {
        title = tostring(title or "Catch"),
        color = 3447003,
        fields = fields or {},
        footer = { text = "discord.gg/limithub" },
        timestamp = DateTime.now():ToIsoDate()
    }
    pcall(function()
        req({
            Url = state.url, Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode({ content = "", embeds = { embed } })
        })
    end)
end

-- =======================================================================
-- Resolver Fish (rarity + rbxassetid -> thumbnail)
-- =======================================================================
local function _norm(s) return (tostring(s or ""):lower():gsub("[^%w]+"," "):gsub("%s+"," ")) end

local TierMap = {
    [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Epic",
    [5]="Legendary / Mythic",[6]="Mythic",[7]="Secret",
}
local RarityColor = {
    Common=0x95A5A6, Uncommon=0x2ECC71, Rare=0x3498DB, Epic=0x9B59B6,
    Legendary=0xF1C40F, Mythic=0xE67E22, Secret=0xE74C3C
}

local _fishCache = {}  

local function _extractAssetId(s)
    if type(s)~="string" then return nil end
    return s:match("rbxassetid://(%d+)") or s:match("(%d+)$")
end

local function _thumbFromAssetId(assetStr)
    local id = _extractAssetId(assetStr)
    if not id then return nil end
    local ok, res = pcall(function()
        local url = ("https://thumbnails.roblox.com/v1/assets?assetIds=%s&size=420x420&format=Png&isCircular=false"):format(id)
        local raw = game:HttpGet(url)
        return HttpService:JSONDecode(raw)
    end)
    if ok and res and res.data and res.data[1] and res.data[1].imageUrl then
        return res.data[1].imageUrl
    end
    return nil
end

local function resolveFishInfoByName(name)
    if not name or name=="" then return nil end
    local key = _norm(name)
    if _fishCache[key] then return _fishCache[key] end

    local Items = ReplicatedStorage:FindFirstChild("Items")
    if not Items then return nil end

    local found
    for _, ms in ipairs(Items:GetDescendants()) do
        if ms:IsA("ModuleScript") then
            local ok, mod = pcall(require, ms)
            if ok and type(mod)=="table" then
                local d = mod.Data or mod.data or mod
                if d and d.Name and _norm(d.Name)==key then
                    local rarity = (d.Tier and TierMap[d.Tier]) or "(unknown)"
                    found = {
                        name = d.Name,
                        rarity = rarity,
                        iconUrl = d.Icon and _thumbFromAssetId(d.Icon) or nil, -- KONVERSI rbxassetid -> thumbnail URL
                    }
                    break
                end
            end
        end
    end

    _fishCache[key] = found
    return found
end

local function _passRarityFilter(r)
    local set = WebhookState._raritySet
    if not set or next(set) == nil then return true end
    return set[_normR(r)] == true
end

local AUTHOR_ICON = "https://cdn.discordapp.com/attachments/1412614172302381106/1412899628629758122/B43515AA-FBA7-4D37-B830-5C531B5A0158.png?ex=68b9f8d1&is=68b8a751&hm=8fe9bfd14168ce1f09becd02b388734f2a257f726afbde62ecc9a9f18d0e7c2e"

local Stats = { counts = {}, dirty = false }

local function Stats_Add(name, n)
    name = tostring(name or ""):gsub("^%s+",""):gsub("%s+$","")
    if name == "" then return end
    Stats.counts[name] = (Stats.counts[name] or 0) + (n or 1)
    Stats.dirty = true
end
local function Stats_Reset()
    for k in pairs(Stats.counts) do Stats.counts[k] = nil end
    Stats.dirty = true
end

-- SECTION di tab Webhook
local PlayerStatsSection = WebhookTab:AddSection("Player Stats Webhook")

WebhookState.statsUrl     = WebhookState.statsUrl     or ""
WebhookState.statsEnabled = WebhookState.statsEnabled or false
WebhookState.statsMsgId   = WebhookState.statsMsgId   or nil
WebhookState.lastStats    = WebhookState.lastStats    or ""

PlayerStatsSection:AddInput("StatsWebhookURL", {
    Title = "Stats Webhook URL",
    Placeholder = "Paste webhook link for Player Stats!",
    Default = WebhookState.statsUrl or "",
    Callback = function(text)
        WebhookState.statsUrl = tostring(text or "")
    end
})

PlayerStatsSection:AddToggle("StatsToggle", {
    Title = "Enable Player Stats",
    Description = "Edit one webhook message with your fish list",
    Default = WebhookState.statsEnabled or false,
    Callback = function(on)
        WebhookState.statsEnabled = not not on
    end
})

PlayerStatsSection:AddButton({
    Title = "Reset Stats",
    Description = "Clear local fish counters (webhook will be updated)",
    Callback = function()
        Stats_Reset()
    end
})

-- waktu lokal aman
local function _clockStr()
    local ok, s = pcall(function() return os.date("%H:%M:%S") end)
    return ok and s or "00:00:00"
end


local MUT_PREFIX = {
    ["ghost"]=true, ["stone"]=true, ["gold"]=true,
    ["albino"]=true, ["shiny"]=true, ["big"]=true, ["corrupt"]=true, ["radioactive"]=true,
}
local function baseNameForRarity(displayName)
    local words = {}
    for w in tostring(displayName or ""):gmatch("%S+") do table.insert(words, w) end
    if #words == 0 then return displayName end
    local first = words[1]:lower()
    if MUT_PREFIX[first] and #words >= 2 then
        table.remove(words, 1)
        return table.concat(words, " ")
    end
    return displayName
end

-- urutan prioritas rarity untuk section
local RARITY_ORDER = { "Secret","Mythic","Legendary","Epic","Rare","Common","Uncommon" }
local RARITY_INDEX = {}
for i, r in ipairs(RARITY_ORDER) do RARITY_INDEX[r] = i end

-- build embeds: grouped by rarity (bold), hanya show rarity yang ada
local function buildStatsEmbeds_fromCounts()
    local groups = {}
    local any = false

    for dispName, n in pairs(Stats.counts) do
        local base = baseNameForRarity(dispName)
        local info = resolveFishInfoByName(base)
        local rarity = (info and info.rarity) or "(unknown)"
        if rarity == "Legendary" then rarity = "Mythic" end

        if RARITY_INDEX[rarity] then
            any = true
            groups[rarity] = groups[rarity] or {}
            table.insert(groups[rarity], string.format("- %s x%d", dispName, tonumber(n) or 0))
        end
    end

    local embeds = {{
        author = { name = "LimitHub", icon_url = AUTHOR_ICON },
        title  = "LimitHub - Static Player",
        description = string.format("Player Name : ||%s||", LocalPlayer.Name),
        color  = 0x00BFFF,
        thumbnail = { url = AUTHOR_ICON },
        footer = { text = string.format("discord.gg/limithub â€¢ Last update %s", _clockStr()) },
        timestamp = DateTime.now():ToIsoDate()
    }}
    if not any then return embeds end

    local sections = {}
    for _, rarity in ipairs(RARITY_ORDER) do
        local list = groups[rarity]
        if list and #list > 0 then
            table.sort(list)
            table.insert(sections, string.format("**%s** :\n%s", rarity, table.concat(list, "\n")))
        end
    end
    local desc = table.concat(sections, "\n\n")

    local MAX = 1800
    local function splitText(t, maxlen)
        local parts = {}
        while #t > maxlen do
            local cut = t:sub(1, maxlen)
            local p = cut:match("^(.*)\n") or cut
            table.insert(parts, p)
            t = t:sub(#p + 2)
        end
        if #t > 0 then table.insert(parts, t) end
        return parts
    end

    local chunks = splitText(desc, MAX)
    for i, chunk in ipairs(chunks) do
        table.insert(embeds, {
            description = chunk,
            color = 0x00BFFF,
            thumbnail = { url = AUTHOR_ICON },
            footer = { text = string.format("discord.gg/limithub â€¢ Last update %s%s",
                      _clockStr(), (#chunks>1 and (" â€¢ Page "..i.."/"..#chunks) or "")) },
            timestamp = DateTime.now():ToIsoDate()
        })
    end

    return embeds
end

local function updateStatsWebhook_fromCounts()
    if not WebhookState.statsEnabled or WebhookState.statsUrl == "" then return end

    local embeds  = buildStatsEmbeds_fromCounts()
    local payload = HttpService:JSONEncode({ embeds = embeds })

    if payload == WebhookState.lastStats then return end
    WebhookState.lastStats = payload

    local req = (syn and syn.request) or (http and http.request) or http_request or request
    if not req then return end

    pcall(function()
        if WebhookState.statsMsgId then
            local editUrl = WebhookState.statsUrl .. "/messages/" .. WebhookState.statsMsgId
            req({ Url = editUrl, Method = "PATCH", Headers = {["Content-Type"]="application/json"}, Body = payload })
        else
            local res = req({
                Url = WebhookState.statsUrl .. "?wait=true",
                Method = "POST",
                Headers = {["Content-Type"]="application/json"},
                Body = payload
            })
            if res and res.Body then
                local ok, json = pcall(function() return HttpService:JSONDecode(res.Body) end)
                if ok and json and json.id then WebhookState.statsMsgId = json.id end
            end
        end
    end)
end

task.spawn(function()
    while true do
        task.wait(4)
        if Stats.dirty then
            Stats.dirty = false
            updateStatsWebhook_fromCounts()
        end
    end
end)

local function sendCatchEmbedOnce(fishName, oddsText, weightNumber)
    local displayName = tostring(fishName or "")
    local base = baseNameForRarity(displayName)
    local info = resolveFishInfoByName(base)

    Stats_Add(displayName, 1)

    local effectiveRarity = (info and info.rarity) or "(unknown)"
    if effectiveRarity == "Legendary / Mythic" then effectiveRarity = "Legendary" end
    if not _passRarityFilter(effectiveRarity) then return end

    if not (WebhookState.enabled and type(WebhookState.url)=="string" and #WebhookState.url>0) then return end
    local req = (syn and syn.request) or (http and http.request) or http_request or request
    if not req then return end

    local fields = {}
    if oddsText then table.insert(fields, { name="Odds", value=tostring(oddsText), inline=true }) end
    if weightNumber then table.insert(fields, { name="Weight", value=string.format("%.2f kg", weightNumber), inline=true }) end

    local embed = {
        author = { name = "LimitHub", icon_url = AUTHOR_ICON },
        title = displayName,
        description = effectiveRarity,
        color = RarityColor[effectiveRarity] or 0x3498DB,
        fields = (#fields>0) and fields or nil,
        footer = { text = "discord.gg/limithub" },
        timestamp = DateTime.now():ToIsoDate()
    }
    if info and info.iconUrl then
        embed.thumbnail = { url = info.iconUrl }
    end

    pcall(function()
        req({
            Url = WebhookState.url,
            Method = "POST",
            Headers = {["Content-Type"]="application/json"},
            Body = HttpService:JSONEncode({ content = "", embeds = { embed } })
        })
    end)
end

SettingsSection:AddButton({ Title = "Rejoin Server", Description = "Rejoin the current server", Callback = Rejoin })
SettingsSection:AddButton({ Title = "Server Hop (New Server)", Description = "Hop to a new server", Callback = ServerHop })

do
    local LP = Players.LocalPlayer
    local PG2 = LP:WaitForChild("PlayerGui")
    local hooked      = setmetatable({}, {__mode = "k"})
    local lastLogAt   = setmetatable({}, {__mode = "k"})

    local function clean(s)
        if not s then return "" end
        s = s:gsub("[%z\1-\127\194-\244][\128-\191]*", function(ch) return (ch:byte() <= 127) and ch or "" end)
        return (s:gsub("^%s+",""):gsub("%s+$",""))
    end

    local function parseFishLine(s)
        s = clean(s)
        local name, kg = s:match("^(.-)%s*%(([%d%.]+)%s*kg%)$")
        if name then return (name:gsub("%s+"," ")), tonumber(kg) end
        return (s:gsub("%s+"," ")), nil
    end

    local function findSiblingInfo(container)
        local odds, fishLine
        for _, d in ipairs(container:GetDescendants()) do
            if d:IsA("TextLabel") then
                local t = clean(d.Text or "")
                if (not odds) and t:match("^(%d+)%s*in%s*(%d+)$") then odds = t:gsub("%s+"," ") end
                if (not fishLine) and (t:match("%(([%d%.]+)%s*kg%)")) then fishLine = t end
            end
            if odds and fishLine then break end
        end
        return odds, fishLine
    end

    local function logOnce(container, name, kg, odds)
        local now = os.clock()
        local last = lastLogAt[container]
        if last and now - last < 0.35 then return end
        lastLogAt[container] = now
        sendCatchEmbedOnce(tostring(name), odds, kg)
    end

    local function tryAssembleFrom(container)
        local odds, fishLine = findSiblingInfo(container)
        if not fishLine then return end
        local name, kg = parseFishLine(fishLine)
        if not name or name == "" then return end
        logOnce(container, name, kg, odds)
    end

    local function hookLabel(lbl)
        if hooked[lbl] then return end
        hooked[lbl] = true
        local function onChange()
            local t = clean(lbl.Text or "")
            if t == "" then return end
            if t:match("^(%d+)%s*in%s*(%d+)$") then tryAssembleFrom(lbl.Parent or lbl); return end
            if t:match("%(([%d%.]+)%s*kg%)") then tryAssembleFrom(lbl.Parent or lbl); return end
            if t:find("^%s*You%s*got") then task.delay(0.06, function() tryAssembleFrom(lbl.Parent or lbl) end) end
        end
        onChange()
        lbl:GetPropertyChangedSignal("Text"):Connect(onChange)
    end

    for _, d in ipairs(PG2:GetDescendants()) do if d:IsA("TextLabel") then hookLabel(d) end end
    PG2.DescendantAdded:Connect(function(obj) if obj:IsA("TextLabel") then hookLabel(obj) end end)
end
