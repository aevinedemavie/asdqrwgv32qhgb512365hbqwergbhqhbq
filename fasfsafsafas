

local Library, SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/jamalarap61/Mslspakwnendlsowjnssoaknana/refs/heads/main/wnsoaowknswlwksnwmk.lua"))()


function gradient(text, startColor, endColor)
    local result = ""
    local length = #text

    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)

        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end

    return result
end


local Window = Library:CreateWindow({
    Title = gradient("LimitHub | Fish It", Color3.fromHex("#8ab4f8"), Color3.fromHex("#00ffe1")),
    Size = UDim2.new(0, 480, 0, 300), 
    TabWidth = 120,
    Theme = "LimitHub",    
    Acrylic = false
})
local ConfigLod = "LimitHub/FishIt/config/FishIt.json"


function NotifyHub(text) 
Library:Notify({
Title = "LimitHub", 
Content = text,
Duration = 5,
})
end


local Tabs = {
    Main     = Window:AddTab({ Title = "Main",     Icon = "star" }),
    Player   = Window:AddTab({ Title = "Player",   Icon = "user" }),
    Event    = Window:AddTab({ Title = "Event",    Icon = "eye" }),
    Enchant  = Window:AddTab({ Title = "Enchant",  Icon = "wand" }),
    Trade    = Window:AddTab({ Title = "Trade Option",  Icon = "airplay"}),
    Shop     = Window:AddTab({ Title = "Shop",     Icon = "shopping-cart" }),
    Teleport = Window:AddTab({ Title = "Teleport",  Icon = "map" }),
    Webhook  = Window:AddTab({ Title = "Webhook Option",  Icon = "link" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "cog" })
}
Window:SelectTab(1)

local DataWoi = {}
-- initialize variable 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local player = Players.LocalPlayer
if not player or not replicatedStorage then
    return
end
local lastEventTime = tick()
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local playerGui = player:WaitForChild("PlayerGui")
local Client = require(replicatedStorage.Packages.Replion).Client
local Data = Client:WaitReplion("Data")
local ItemsFolder = replicatedStorage:WaitForChild("Items")
local REFavoriteItem = replicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RE/FavoriteItem"]
local TierUtility = require(replicatedStorage.Shared.TierUtility)
local itemsFolder = replicatedStorage:FindFirstChild("Items")
local net = replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")
local lastEventTime = tick() -- tick() mengembalikan waktu sekarang dalam detik
local inventoryPage = player.PlayerGui.Inventory.Main.Content.Pages.Inventory
local SellAllButton = player.PlayerGui.Inventory.Main.SellAll
local Remotes = {}

Remotes.RF_ChargeFishingRod = net:WaitForChild("RF/ChargeFishingRod")
Remotes.RF_RequestFishingMinigameStarted = net:WaitForChild("RF/RequestFishingMinigameStarted")
Remotes.RE_FishingCompleted = net:WaitForChild("RE/FishingCompleted")
Remotes.RE_EquipTool = net:WaitForChild("RE/EquipToolFromHotbar")
Remotes.UnEquipTool = net:WaitForChild("RE/UnequipToolFromHotbar")
Remotes.RE_FishingEffect = net:WaitForChild("RE/PlayFishingEffect")
Remotes.RF_AutoFish = net:WaitForChild("RF/UpdateAutoFishingState")
Remotes.RE_EquipItem = net:WaitForChild("RE/EquipItem")
Remotes.RF_InitiateTrade = net:WaitForChild("RF/InitiateTrade")
Remotes.RF_AwaitTradeResponse = net:WaitForChild("RF/AwaitTradeResponse")
Remotes.RERollEnchant = net:WaitForChild("RE/RollEnchant")
Remotes.RE_ActivateEnchantingAltar = net:WaitForChild("RE/ActivateEnchantingAltar")
Remotes.RF_CancelFishing = net:WaitForChild("RF/CancelFishingInputs")


-------FUNGSI STARTFISHING---------

local RE_FishingStopped = net:WaitForChild("RE/FishingStopped")

local dapatIkan = true

local fishCount = 0
local fishCountFarm = 0;
local FishingController = require(replicatedStorage:WaitForChild("Controllers"):WaitForChild("FishingController"))
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Variabel global
local StartRodCharge = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild(
    "StartRodCharge")
local RodThrow = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("RodThrow")
local EquipIdle = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("EquipIdle")

local ReelingIdle = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("ReelingIdle")
local EasyFishReelStart = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild(
    "EasyFishReel")
local FishCaught = replicatedStorage:WaitForChild("Modules"):WaitForChild("Animations"):WaitForChild("FishCaught")

local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

local StartRodChargeAnim = animator:LoadAnimation(StartRodCharge)
local RodThrowAnim = animator:LoadAnimation(RodThrow)
local ReelingIdleAnim = animator:LoadAnimation(ReelingIdle)
local EasyFishReelStartAnim = animator:LoadAnimation(EasyFishReelStart)
local FishCaughtAnim = animator:LoadAnimation(FishCaught)

local FavoriteToggles = {
    Legendary = false,
    Mythical = false,
    Secret = false
}
local toggleState = {
    AutoSell = false,
    fishingAnimation = false,
    autoBuyWeather = false,
    infJump = false,
    loopDelay = 0.1,
    perfectCast = false,
    amazingCast = false,
    floatingPlatform = false,
    autoFix = false,
    autoFishing = false,
    priceValue = false,
    bool_autoFarm = false,
    AutoSellbp = false,
    lockPosition = false
}

local function getFishInfoById(id)
    for _, itemModule in pairs(ItemsFolder:GetChildren()) do
        if itemModule:IsA("ModuleScript") then
            local ok, data = pcall(require, itemModule)
            if ok and data and data.Data and data.Data.Id == id then
                return data
            end
        end
    end
    return nil
end

-- Fungsi untuk favorite ikan sesuai tier
local function favoriteAll()
    local inv = Data:Get("Inventory")
    if not inv or not inv.Items then
        return
    end

    for _, v in pairs(inv.Items) do
        local itemInfo = getFishInfoById(v.Id)
        if itemInfo and itemInfo.Data.Type == "Fishes" then

            if v.UUID and not v.Favorited then
                REFavoriteItem:FireServer(v.UUID)
            end
        end
    end
end

local function unfavoriteAll()
    local inv = Data:Get("Inventory")
    if not inv or not inv.Items then
        return
    end

    for _, v in pairs(inv.Items) do
        local itemInfo = getFishInfoById(v.Id)
        if itemInfo and itemInfo.Data.Type == "Fishes" then
            if v.UUID and v.Favorited then
                REFavoriteItem:FireServer(v.UUID)
            end
        end
    end
end



local currentTracks = {}
local function playWithDuration(id, duration)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")


    for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
        track:Stop()
    end

    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. id

    local track = humanoid:LoadAnimation(anim)
    track:Play()

    -- Stop setelah durasi
    task.delay(duration, function()
        if track.IsPlaying then
            track:Stop()
        end
    end)

    return track
end

local function stopFishing()
    for i = 1, 25 do
        Remotes.RE_FishingCompleted:FireServer()
        task.wait(0.5)
    end
    pcall(function()
        if FishingController and FishingController.RequestClientStopFishing then
            FishingController:RequestClientStopFishing(true)
        end
    end)

end

local function startFishing(val)
    if val then 
        pcall(function()
            local args = {1}
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild(
                "sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RE/EquipToolFromHotbar"):FireServer(
                unpack(args))
        end)

        task.wait(0.8)
        task.spawn(function()
            while val do
 
                for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
                    track:Stop()
                end
                pcall(function()
                    dapatIkan = true

                    if  toggleState.fishingAnimation then
                        StartRodChargeAnim:Play()
                    end

                    Remotes.RF_ChargeFishingRod:InvokeServer(Workspace:GetServerTimeNow())

                    if  toggleState.fishingAnimation then
                        RodThrowAnim:Play() 
                    end

                    task.wait(0.2)

                    -- Hitung x y casting
                    local x, y
                    if toggleState.perfectCast and not toggleState.amazingCast then
                        x, y = -0.7499996423721313, 1
                    elseif not toggleState.perfectCast and toggleState.amazingCast then
                        x, y = -139.63796997070312, 0.8769422639492821
                    else
                        x = math.random(-1000, 1000) / 1000
                        y = math.random(0, 1000) / 1000
                    end

                    if  toggleState.fishingAnimation then 
                            playWithDuration("92624107165273", 2)
                            playWithDuration("134965425664034", 15)
                      end
                    Remotes.RF_RequestFishingMinigameStarted:InvokeServer(x, y)
 
                    task.wait(0.2)

                    if  toggleState.fishingAnimation then
                        EasyFishReelStartAnim:Play()
                    end 
                            local completedArgs = {}
                      while dapatIkan do
                              Remotes.RE_FishingCompleted:FireServer(unpack(completedArgs))
                                task.wait(0.1)
                     end
                end)

                task.wait(toggleState.loopDelay)
            end
        end)
    else
         Remotes.RF_CancelFishing:InvokeServer()
        pcall(function()
            if FishingController and FishingController.RequestClientStopFishing then
                FishingController:RequestClientStopFishing(true)
            end
        end)
        for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
            track:Stop()
        end
       
    end
end


local lockPositionState = {
    enabled = false,
    position = nil
}

local AutoSaveEnabled = true
local LastPosition = {}
-------FUNGSI RESPAWN-----------
local saveFile = "last_position.json"

local function savePosition()

    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        local pos = char.HumanoidRootPart.CFrame
        LastPosition = {pos.X, pos.Y, pos.Z, ({pos:ToOrientation()})[1], ({pos:ToOrientation()})[2],
                        ({pos:ToOrientation()})[3]}
        -- simpan ke file agar tetap ada setelah rejoin
        writefile(saveFile, HttpService:JSONEncode(LastPosition))
    end
end
-- Fungsi untuk restore posisi
local function restorePosition()

    if not AutoSaveEnabled then
        return
    end

    -- baca dari file jika ada
    if isfile(saveFile) then
        local data = HttpService:JSONDecode(readfile(saveFile))
        LastPosition = data
    end

    local saved = LastPosition
    if saved and typeof(saved) == "table" and #saved >= 3 then
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart", 5)

        if hrp then
            task.wait(0.3)
            hrp.CFrame = CFrame.new(saved[1], saved[2], saved[3]) *
                             CFrame.Angles(saved[4] or 0, saved[5] or 0, saved[6] or 0)

        end
    end
end

local function respawnPlayer()

    local character = LocalPlayer.Character
    if character and character:FindFirstChild("Humanoid") then
        character.Humanoid.Health = 0 -- memaksa respawn
    end

    local char = Workspace.Characters:FindFirstChild(LocalPlayer.Name)
    local hrp = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")

end
-------FUNGSI ROD MODIFIER---------
local function antiAfk()

    local vu = game:GetService("VirtualUser")
    Players.LocalPlayer.Idled:Connect(function()
        vu:Button2Down(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
        task.wait(1)
        vu:Button2Up(Vector2.new(0, 0), Workspace.CurrentCamera.CFrame)
        vu:CaptureController()
        vu:ClickButton2(Vector2.new())
    end)

end
antiAfk()
local function startModifier()

    for _, module in ipairs(itemsFolder:GetChildren()) do
        if module:IsA("ModuleScript") then
            local success, rodData = pcall(require, module)
            if success and type(rodData) == "table" then
                rodData.ClickPower = 9999
                rodData.Resilience = 9999
                rodData.Speed = 100
                rodData.MaxWeight = 1000000
            end
            if success and type(rodData) == "table" and rodData.RollData then

                rodData.RollData.BaseLuck = 9999
                if not rodData.RollData.Frequency then
                    rodData.RollData.Frequency = {}
                end
                rodData.RollData.Frequency.Golden = 100
                rodData.RollData.Frequency.Rainbow = 100

                --  print("Rod:", module.Name, "-> BaseLuck:", rodData.RollData.BaseLuck)
            end
        end
    end

    -- === Modify Baits ===
    local baitsFolder = replicatedStorage:WaitForChild("Baits")

    for _, bait in pairs(baitsFolder:GetChildren()) do
        if bait:IsA("ModuleScript") then
            local success, baitModule = pcall(require, bait)
            if success and baitModule and baitModule.Modifiers then

                if baitModule.Modifiers == nil then
                    baitModule.Modifiers = {}
                end
                baitModule.Modifiers.BaseLuck = 99999

                if baitModule.Modifiers.ShinyMultiplier == nil then
                    baitModule.Modifiers.ShinyMultiplier = 99999
                end
                if baitModule.Modifiers.MutationMultiplier == nil then
                    baitModule.Modifiers.MutationMultiplier = 99999
                end

                -- print("Bait updated:", bait.Name)
            else
                warn("Gagal load bait:", bait.Name)
            end
        end
    end

end

local thresholdbp = 4990
local function obtainedNewFish()

    local bagSize = 0
    local backpackGui = player.PlayerGui:FindFirstChild("Backpack")
    if backpackGui then
        local display = backpackGui:FindFirstChild("Display")
        local inventory = display and display:FindFirstChild("Inventory")
        local bagSizeLabel = inventory and inventory:FindFirstChild("BagSize")

        if bagSizeLabel and bagSizeLabel:IsA("TextLabel") then
            bagSize = bagSizeLabel.Text
            local currentStr = bagSize:match("^(%d+)") -- "3000" 

            local current = tonumber(currentStr)
            if (toggleState.AutoSellbp and current >= thresholdbp) then
                replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
            end
            if current and current >= 4995 then
                replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
            end
        end

    end
end

local function getBagSize()
    local bagSize = 0
    pcall(function()
        local backpackGui = player.PlayerGui:WaitForChild("Backpack", 5)
        if backpackGui then
            local bagSizeLabel = backpackGui:FindFirstChild("Display", true) and
                                     backpackGui.Display:FindFirstChild("Inventory", true) and
                                     backpackGui.Display.Inventory:FindFirstChild("BagSize", true)
            if bagSizeLabel and bagSizeLabel:IsA("TextLabel") then
                local current = bagSizeLabel.Text:match("^(%d+)")
                if current then
                    bagSize = tonumber(current)
                    if (toggleState.AutoSellbp and bagSize >= thresholdbp) then
                        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
                    end

                    if bagSize >= 4998 then
                        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
                    end
                end
            end
        end
    end)
    return bagSize
end

local selectedIslands = {}

-- sell allfish

local totalPrice = 0

-- Fungsi untuk cari module berdasarkan nama ikan ya
local function findItemModule2(fullName)
    local itemsFolder = replicatedStorage:FindFirstChild("Items")
    if not itemsFolder then
        return nil
    end

    local cleanedName = fullName or ""
    -- kita clean dulu namanya biar gak ada mutasina ikut
    cleanedName = cleanedName:gsub("%s*%b()", ""):gsub("^%s*(.-)%s*$", "%1")
    local cleanedLower = string.lower(cleanedName)

    local bestMatch, longest = nil, 0
    for _, mod in ipairs(itemsFolder:GetChildren()) do
        if mod:IsA("ModuleScript") then
            local modNameLower = string.lower(mod.Name)
            if cleanedLower:find(modNameLower, 1, true) then
                if #mod.Name > longest then
                    longest = #mod.Name
                    bestMatch = mod
                end
            end
        end
    end
    -- cek yang paling terdekat
    if bestMatch then

        return bestMatch
    end

    for _, mod in ipairs(itemsFolder:GetChildren()) do
        if mod:IsA("ModuleScript") then
            local ok, mdata = pcall(require, mod)
            if ok and type(mdata) == "table" and mdata.Data and type(mdata.Data.Name) == "string" then
                local modDataName = mdata.Data.Name
                local modClean = modDataName:gsub("%s*%b()", ""):gsub("^%s*(.-)%s*$", "%1")
                if string.lower(modClean) == cleanedLower or string.lower(modDataName) == cleanedLower then

                    return mod
                end
            end
        end
    end

    return nil
end

-- Tambah TextLabel harga di bawah ItemName biar pas
local function addSellPriceLabel(itemFrame, price)
    -- Jangan bikin duplikat kalau sudah ada
    if itemFrame:FindFirstChild("SellPriceLabel") then
        itemFrame.SellPriceLabel.Text = "$ " .. tostring(price)
        return
    end

    local label = Instance.new("TextLabel")
    label.Name = "SellPriceLabel"
    label.Text = "$ " .. tostring(price)
    label.Size = UDim2.new(1, 0, 0, 24) -- lebih besar dari default
    label.Position = UDim2.new(0, 0, 0, itemFrame.ItemName.AbsoluteSize.Y + 2) -- tepat di bawah ItemName
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 215, 0) -- warna emas
    label.Font = Enum.Font.GothamBold
    label.TextScaled = true
    label.Parent = itemFrame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(0, 0, 0)
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Contextual
    stroke.Parent = label

end

local function updateInventoryLabels()
    totalPrice = 0
    for _, child in ipairs(inventoryPage:GetChildren()) do
        if child:FindFirstChild("ItemName") then
            local itemName = child.ItemName.Text
            local module = findItemModule2(itemName)
            if module then
                local ok, mdata = pcall(require, module)

                if ok and mdata and mdata.Data and mdata.SellPrice then
                    addSellPriceLabel(child, mdata.SellPrice)
                end
                if mdata and mdata.SellPrice and mdata.Data.Type == "Fishes" then
                    totalPrice = totalPrice + mdata.SellPrice
                end
            end
        end
    end

    local player = game:GetService("Players").LocalPlayer
    local inventory = player:WaitForChild("PlayerGui"):WaitForChild("Inventory")
    local main = inventory:WaitForChild("Main")
    local sellAll = main:WaitForChild("SellAll")
    local label = sellAll:WaitForChild("Label")
    label.Text = totalPrice

end

local function getFishInfoById(id)
    for _, itemModule in pairs(ItemsFolder:GetChildren()) do
        if itemModule:IsA("ModuleScript") then
            local ok, data = pcall(require, itemModule)
            if ok and data and data.Data and data.Data.Id == id then
                return data
            end
        end
    end
    return nil
end
if toggleState.priceValue then
    updateInventoryLabels()
end

-- obtainednewfish--
local RemoteFishCaught =
    game:GetService("ReplicatedStorage").Packages._Index["sleitnick_net@0.2.0"].net["RE/ObtainedNewFishNotification"]

RemoteFishCaught.OnClientEvent:Connect(function(...)
    dapatIkan = false
    lastEventTime = tick()
    obtainedNewFish()
    fishCount = fishCount + 1
    fishCountFarm = fishCountFarm + 1
    if (toggleState.AutoSell and fishCount >= threshold) then
        -- Jika auto sell aktif dan jumlah ikan >= threshold, teleport
        fishCount = 0
        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
    end

    if (toggleState.AutoSellbp and getBagSize() >= thresholdbp) then 
        replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
    end

    if (toggleState.bool_autoFarm and fishCountFarm >= AutoFarmThreshold) then
        fishCountFarm = 0
        task.wait(0.8)
        TeleportRandom()
    end

    if toggleState.priceValue then
        updateInventoryLabels()
    end

    local args = {...}
    for _, v in ipairs(args) do
        if type(v) == "table" and v.InventoryItem and v.InventoryItem.UUID then
            local uuid = v.InventoryItem.UUID
            local idFish = v.InventoryItem.Id
            local itemInfo = getFishInfoById(idFish)

            if itemInfo and itemInfo.Data.Type == "Fishes" and itemInfo.Probability then
                local tierData = TierUtility.GetTierFromRarity(nil, itemInfo.Probability.Chance)
                if tierData then
                    if tierData.Name == "Legendary" and FavoriteToggles.Legendary then
                        REFavoriteItem:FireServer(uuid)
                    elseif tierData.Name == "Mythic" and FavoriteToggles.Mythical then
                        REFavoriteItem:FireServer(uuid)
                    elseif tierData.Name == "SECRET" and FavoriteToggles.Secret then
                        REFavoriteItem:FireServer(uuid)
                    end
                end
            end
        end
    end

end)



local FishingSec = Tabs.Main:AddSection("Auto Fishing")

FishingSec:AddDropdown("Cast_Mode", {
Title = "Cast Mode",
Description = "Select Mode",
Values = {"Random", "Perfect", "Amazing"}, 
Default = "Random",
Multi = false, 
AllowNull = true, 
Callback = function(option)
        if option == "Perfect" then
            toggleState.perfectCast = true
            toggleState.amazingCast = false

        elseif option == "Amazing" then
            toggleState.amazingCast = true
            toggleState.perfectCast = false

        elseif option == "Random" then
            toggleState.perfectCast = false
            toggleState.amazingCast = false

        end
end
})

DataWoi.AutoMancing = false
local ToggleFS = FishingSec:AddToggle("Auto_Fishingnew",{
Title = "Auto Fishing",
Description = "Only Turn on this if want Animation",
Default = false,
Callback = function(value)
        if value then
            if DataWoi.AutoMancing then return end
            DataWoi.AutoMancing = true
            toggleState.autoFishing = true
            startFishing(value)        
        else
            if DataWoi.AutoMancing then
            startFishing(value)        
            DataWoi.AutoMancing = false
            toggleState.autoFishing = false
        end
    end
end
})

DataWoi.InstantCatch = false
FishingSec:AddToggle("Instant_Catch",{
Title = "No Animation",
Description = "Turn On This if want Without Animation",
Default = false,
Callback = function(value)
        if value then
            if DataWoi.InstantCatch then return end
            Data.InstantCatch = true
            toggleState.fishingAnimation = false
        else
            DataWoi.InstantCatch = false
            toggleState.fishingAnimation = true
        end
end
})


local freezeConnection = nil
local freezeCFrame = nil
local originalPlatformStand = nil

local freezecok = FishingSec:AddToggle("Freeze Character", {
    Title = "Freeze Character",
    Description = "Freeze your character",
    Default = false,
    Callback = function(Value)
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")

        if Value then
            if freezeConnection then return end -- biar gak dobel

            freezeCFrame = hrp.CFrame
            originalPlatformStand = hum and hum.PlatformStand

            if hum then
                hum.PlatformStand = true
            end
            freezeConnection = RunService.Heartbeat:Connect(function()
                if not hrp or not hrp.Parent then return end
                pcall(function()
                    hrp.AssemblyLinearVelocity = Vector3.zero
                    hrp.AssemblyAngularVelocity = Vector3.zero
                    hrp.Velocity = Vector3.zero
                    hrp.RotVelocity = Vector3.zero
                    hrp.CFrame = freezeCFrame
                end)
            end)

            print("[Freeze] Active")
        else
            if freezeConnection then
                freezeConnection:Disconnect()
                freezeConnection = nil
            end

            if hum and originalPlatformStand ~= nil then
                hum.PlatformStand = originalPlatformStand
                originalPlatformStand = nil
            end

            freezeCFrame = nil
        end
    end
})


DataWoi.AutoFixStuck = false
FishingSec:AddToggle("Auto_Fix",{
Title = "Auto Fix Stuck",
Description = "Fishing Stuck",
Default = false,
Callback = function(value)
        if value then
            if DataWoi.FixStuck then return end
            DataWoi.FixStuck = true
            toggleState.autoFix = true
        else
            DataWoi.FixStuck = false
            toggleState.autoFix = false
        end
end
})

task.spawn(function()
    while true do
        task.wait(3)
        local elapsed = tick() - lastEventTime
        if elapsed > 5 and toggleState.autoFishing and toggleState.autoFix then
            ToggleFS:SetValue(false)
            task.wait(1.5)
            game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/CancelFishingInputs"):InvokeServer()
            task.wait(1.5)
            ToggleFS:SetValue(true)
            NotifyHub("Auto Fixed Stuck Fishing")
            lastEventTime = tick()
        end
    end
end)

FishingSec:AddButton({
Title = "Manual Fix Stuck",
Description = "If Stuck Fishing",
Callback = function()
game:GetService("ReplicatedStorage"):WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/CancelFishingInputs"):InvokeServer()
end
})


local SellSec = Tabs.Main:AddSection("Auto Sell Fish")
Data.AutoMaxBP = false

SellSec:AddInput("Threshold_Sell",{
Title = "Input: Sell Threshold",
Description = "Amount Fish",
Placeholder = "5000",
Numeric = true,
Finished = true,
Callback = function(Value)
thresholdbp = tonumber(Value)
end
})

SellSec:AddToggle("Auto_Sell",{
Title = "Auto Sell Threshold",
Description = "Auto Sell Fish",
Default = false,
Callback = function(value)
if value then
    if Data.AutoMaxBP then return end
    Data.AutoMaxBP = true
    toggleState.AutoSellbp = true
else
    Data.AutoMaxBP = false
    toggleState.AutoSellbp = false
end
end
})

SellSec:AddButton({
Title = "Sell All Fish 1x", 
Callback = function()
replicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net"):WaitForChild("RF/SellAllItems"):InvokeServer()
end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Net = ReplicatedStorage
    :WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

-- Remotes (pakai nama dengan slash, sesuai struktur game kamu)
local PurchaseBaitRF = PurchaseBaitRF or Net:WaitForChild("RF/PurchaseBait")
local PurchaseRodRF  = PurchaseRodRF  or Net:WaitForChild("RF/PurchaseFishingRod")
local PurchaseBoatRF = PurchaseBoatRF or Net:WaitForChild("RF/PurchaseBoat")
local PurchaseGearRF = PurchaseGearRF or Net:WaitForChild("RF/PurchaseGear")

-- Global state
local G = (getgenv and getgenv()) or _G
G.__SelectedBaitId = G.__SelectedBaitId or nil
G.__SelectedRodId  = G.__SelectedRodId  or nil
G.__SelectedBoatId = G.__SelectedBoatId or nil
G.__SelectedItemId = G.__SelectedItemId or nil


BaitIds = BaitIds or {
    ["Luck Bait"]        = 2,
    ["Midnight Bait"]    = 3,
    ["Nature Bait"]      = 4,
    ["Chroma Bait"]      = 5,
    ["Dark Matter Bait"] = 6,
    ["Corrupt Bait"]     = 7,
    ["Aether Bait"]      = 8,
}
BaitList = BaitList or {
    "Luck Bait","Midnight Bait","Nature Bait","Chroma Bait",
    "Dark Matter Bait","Corrupt Bait","Aether Bait"
}

local BobberSection = Tabs.Shop:AddSection("Bobbers Shop")
BobberSection:AddDropdown("BaitDropdown", {
    Title = "Select: Bait",
    Values = BaitList,
    Default = nil,
    Multi = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and BaitIds[value]
        if id then
            G.__SelectedBaitId = id
            warn(("[Bait] Selected '%s' -> id=%s"):format(value, tostring(id)))
        else
            G.__SelectedBaitId = nil
            warn("[Bait] Unknown selection: " .. tostring(value))
        end
    end
})
BobberSection:AddButton({
    Title = "Buy Selected Bait",
    Callback = function()
        local id = G.__SelectedBaitId
        if not id then return warn("[Bait] Please select a bait first!") end
        local ok, res = pcall(function() return PurchaseBaitRF:InvokeServer(id) end)
        if ok then print("[Bait] Result:", res) else warn("[Bait] Failed:", res) end
    end
})

-- ---------- ROD SHOP ----------
local RodSection = Tabs.Shop:AddSection("Rod Shop")

local RodIds = {
    ["Luck Rod"]      = 79,   -- 350
    ["Carbon Rod"]    = 76,   -- 900
    ["Grass Rod"]     = 85,   -- 1.5K
    ["Demascus Rod"]  = 77,   -- 3K
    ["Ice Rod"]       = 78,   -- 5K
    ["Lucky Rod"]     = 4,    -- 15K
    ["Angler Rod"]    = 168,  -- 8,000K
    ["Ares Rod"]      = 126,  -- 3,000K
    ["Astral Rod"]    = 5,    -- 1,000K
    ["Chrome Rod"]    = 7,    -- 437K  -- <- konsisten
    ["Midnight Rod"]  = 80,   -- 50K
    ["Steampunk Rod"] = 6,    -- 215K
}

local RodList = {
    "Luck Rod","Carbon Rod","Grass Rod","Demascus Rod","Ice Rod","Lucky Rod",
    "Angler Rod","Ares Rod","Astral Rod","Chrome Rod","Midnight Rod","Steampunk Rod" -- <- ganti Pod -> Rod
}

RodSection:AddDropdown("RodDropdown", {
    Title   = "Select Rod",
    Values  = RodList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and RodIds[value]
        if not id then
            G.__SelectedRodId = nil
            warn("[Rod] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedRodId = id
        warn(("[Rod] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})

RodSection:AddButton({
    Title = "Buy Selected Rod",
    Description = "Purchase the rod selected in the dropdown",
    Callback = function()
        local id = G.__SelectedRodId
        if not id then return warn("[Rod] Please select a rod first!") end
        -- Sama seperti contohmu: argumen tunggal angka
        local ok, res = pcall(function() return PurchaseRodRF:InvokeServer(id) end)
        if ok then
            print("[Rod] Result:", res)
        else
            warn("[Rod] Failed:", res)
            -- Kalau masih gagal, coba format alternatif:
            -- local ok2, res2 = pcall(function() return PurchaseRodRF:InvokeServer({id}) end)
            -- print("Alt tbl arg:", ok2, res2)
        end
    end
})

-- ---------- BOAT SHOP ----------
local BoatSection = Tabs.Shop:AddSection("Boat Shop")

local BoatIds = {
    ["Small Boat"]     = 1, -- 300
    ["Kayak"]          = 2, -- 1.1k
    ["Jetski"]         = 3, -- 7.5k
    ["Highfield Boat"] = 4, -- 25k
    ["Speed Boat"]     = 5, -- 70k
    ["Fishing Boat"]   = 6, -- 180k
    ["Mini Yacht"]     = 7, -- 1.20m
}
local BoatList = {"Small Boat","Kayak","Jetski","Highfield Boat","Speed Boat","Fishing Boat","Mini Yacht"}

BoatSection:AddDropdown("BoatDropdown", {
    Title   = "Select Boat",
    Values  = BoatList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and BoatIds[value]
        if not id then
            G.__SelectedBoatId = nil
            warn("[Boat] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedBoatId = id
        warn(("[Boat] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})
BoatSection:AddButton({
    Title = "Buy Selected Boat",
    Callback = function()
        local id = G.__SelectedBoatId
        if not id then return warn("[Boat] Please select a boat first!") end
        local ok, res = pcall(function() return PurchaseBoatRF:InvokeServer(id) end)
        if ok then print("[Boat] Result:", res) else warn("[Boat] Failed:", res) end
    end
})

local ItemsSection = Tabs.Shop:AddSection("Items Shop")
local ItemIds = { ["Diving Gear"] = 105, ["Fishing Radar"] = 81 }
local ItemList = { "Diving Gear", "Fishing Radar" }

ItemsSection:AddDropdown("ItemDropdown", {
    Title   = "Select Item",
    Values  = ItemList,
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        local id = value and ItemIds[value]
        if not id then
            G.__SelectedItemId = nil
            warn("[Item] Unknown selection: " .. tostring(value))
            return
        end
        G.__SelectedItemId = id
        warn(("[Item] Selected '%s' -> id=%s"):format(value, tostring(id)))
    end
})
ItemsSection:AddButton({
    Title = "Buy Selected Item",
    Callback = function()
        local id = G.__SelectedItemId
        if not id then return warn("[Item] Please select an item first!") end
        local ok, res = pcall(function() return PurchaseGearRF:InvokeServer(id) end)
        if ok then print("[Item] Result:", res) else warn("[Item] Failed:", res) end
    end
})

local WeatherSection = Tabs.Shop:AddSection("Weather Shop")

local __autoWeatherOn = false
local __selectedWeathers = {}

local function _normW(s)
    return (tostring(s or ""):gsub("^%s+",""):gsub("%s+$",""):lower())
end
local WeatherAlias = { ["strom"] = "Storm" }

local function __purchaseWeather(preset)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local ok, res = pcall(function()
        local canon = WeatherAlias[_normW(preset)] or preset
        local args = { tostring(canon or "Wind") }
        local rf = ReplicatedStorage
            :WaitForChild("Packages")
            :WaitForChild("_Index")
            :WaitForChild("sleitnick_net@0.2.0")
            :WaitForChild("net")
            :WaitForChild("RF/PurchaseWeatherEvent")
        return rf:InvokeServer(unpack(args))
    end)
    if not ok then warn("[Weather] Invoke failed:", res) end
    return ok, res
end

local function __purchaseAll(list)
    for _, w in ipairs(list) do __purchaseWeather(w) end
end

task.spawn(function()
    while task.wait(10) do
        if __autoWeatherOn and #__selectedWeathers > 0 then
            __purchaseAll(__selectedWeathers)
        end
    end
end)

local WeatherValues = {
    Wind    = "Wind",
    Cloudy  = "Cloudy",
    Snow    = "Snow",
    Strom   = "Strom",
    Radiant = "Radiant",
    ["Shark Hunt"] = "Shark Hunt",
}

WeatherSection:AddDropdown("WeatherChoice", {
    Title = "Weather Preset",
    Values = WeatherValues,
    Multi  = true,
    Default = {},
    Callback = function(valMap)
        __selectedWeathers = {}
        if type(valMap) == "table" then
            for label, chosen in pairs(valMap) do
                if chosen then table.insert(__selectedWeathers, tostring(label)) end
            end
        elseif type(valMap) == "string" then
            __selectedWeathers = { valMap }
        end
    end
})

WeatherSection:AddToggle("AutoWeatherToggle", {
    Title = "Auto Weather",
    Description = "Auto purchase selected weather",
    Default = false,
    Callback = function(state)
        __autoWeatherOn = state and true or false
        if __autoWeatherOn and #__selectedWeathers > 0 then
            __purchaseAll(__selectedWeathers)
        end
    end
})

local Movement = {
    SpeedEnabled   = false,
    SpeedValue     = 100,
    InfJump        = false,
    NoClip         = false,
}

local Sec_Movement = Tabs.Player:AddSection("Movement")

Sec_Movement:AddToggle("LH_Speed", {
    Title = "Enable WalkSpeed",
    Default = false,
    Callback = function(on)
        Movement.SpeedEnabled = on
        pcall(function()
            local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
            local hum  = char:FindFirstChildOfClass("Humanoid")
            if hum then hum.WalkSpeed = on and Movement.SpeedValue or 16 end
        end)
    end
})

Sec_Movement:AddSlider("LH_SpeedVal", {
    Title = "WalkSpeed Value",
    Description = "Adjust your walk speed",
    Default = 100,
    Min = 16,
    Max = 200,
    Rounding = 0,
    Callback = function(v)
        Movement.SpeedValue = v
        if Movement.SpeedEnabled then
            pcall(function()
                local char = LocalPlayer.Character
                local hum  = char and char:FindFirstChildOfClass("Humanoid")
                if hum then hum.WalkSpeed = v end
            end)
        end
    end
})

Sec_Movement:AddToggle("LH_InfJump", {
    Title = "Enable Infinite Jump",
    Default = false,
    Callback = function(on)
        Movement.InfJump = on
    end
})

Sec_Movement:AddToggle("LH_NoClip", {
    Title = "Enable NoClip",
    Default = false,
    Callback = function(on)
        Movement.NoClip = on
        if not on then
            pcall(function()
                local char = LocalPlayer.Character
                if char then
                    for _, p in ipairs(char:GetDescendants()) do
                        if p:IsA("BasePart") then p.CanCollide = true end
                    end
                end
            end)
        end
    end
})

-- Infinite Jump
pcall(function()
    game:GetService("UserInputService").JumpRequest:Connect(function()
        if Movement.InfJump then
            local char = LocalPlayer.Character
            local hum  = char and char:FindFirstChildOfClass("Humanoid")
            if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
        end
    end)
end)


RunService.Stepped:Connect(function()
    if Movement.NoClip then
        local char = LocalPlayer.Character
        if char then
            for _, p in ipairs(char:GetDescendants()) do
                if p:IsA("BasePart") then p.CanCollide = false end
            end
        end
    end
end)


LocalPlayer.CharacterAdded:Connect(function(char)
    if Movement.SpeedEnabled then
        local hum = char:WaitForChild("Humanoid", 5)
        if hum then hum.WalkSpeed = Movement.SpeedValue end
    end
end)

-- ===== Services =====
local Players     = game:GetService("Players")
local Workspace   = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

getgenv().eventSet = getgenv().eventSet or {
    enabled          = false,
    selectedEvents   = {},   -- selalu disimpan sbg array hasil normalisasi
    originalPosition = nil,
    platform         = nil,
    isAtEvent        = false
}

local EventSection = Tabs.Event:AddSection("Auto Event")

getgenv().eventNames = {
    "Megalodon Hunt", "Admin Event", "Ghost Worm", "Worm Hunt",
    "Shark Hunt", "Ghost Shark Hunt", "Shocked", "Black Hole", "Meteor Rain"
}

-- helper: normalisasi value dropdown (array/string/dictionary -> array)
local function normalizeSelection(value)
    local out = {}
    if type(value) == "table" then
        local hasBool = false
        for _, v in pairs(value) do
            if type(v) == "boolean" then hasBool = true break end
        end
        if hasBool then
            -- dictionary boolean
            for name, enabled in pairs(value) do
                if enabled then table.insert(out, tostring(name)) end
            end
        else
            -- array
            for _, name in ipairs(value) do
                table.insert(out, tostring(name))
            end
        end
    elseif type(value) == "string" then
        out = { value }
    end
    return out
end

EventSection:AddDropdown("AE_SelectEvents", {
    Title     = "Select Events",
    Values    = getgenv().eventNames,
    AllowNone = true,
    Multi     = true,
    Default   = {}, -- jangan auto pilih
    Callback  = function(value)
        getgenv().eventSet.selectedEvents = normalizeSelection(value)
    end
})

EventSection:AddToggle("AE_AutoEvent", {
    Title   = "Auto Event",
    Desc    = "Automatically teleports you to the chosen spawned event.",
    Value   = false,
    Callback = function(value)
        local S = getgenv().eventSet
        S.enabled = value
        if not value and S.isAtEvent then
            local char = LocalPlayer.Character
                or (Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild(LocalPlayer.Name))
            local hrp  = char and char:FindFirstChild("HumanoidRootPart")
            if hrp and S.originalPosition then
                if hrp.Anchored then hrp.Anchored = false; task.wait(0.05) end
                hrp.CFrame = S.originalPosition
                pcall(function()
                    if lockPositionState and lockPositionState.enabled then
                        lockPositionState.position = hrp.CFrame
                    end
                end)
            end
            S.isAtEvent = false
        end
    end
})

-- ===== Finder =====
local function findEventPart(eventName)
    local menuRings = Workspace:FindFirstChild("!!! MENU RINGS")
    if not menuRings then return nil end

    local eventNameLower = eventName:lower()
    for _, propsFolder in ipairs(menuRings:GetChildren()) do
        if propsFolder.Name == "Props" then
            for _, child in ipairs(propsFolder:GetChildren()) do
                if child.Name:lower() == eventNameLower then
                    if child:IsA("Model") then
                        local part = child.PrimaryPart or child:FindFirstChildWhichIsA("BasePart")
                        if part then return part end
                    elseif child:IsA("BasePart") then
                        return child
                    end
                end
                for _, descendant in ipairs(child:GetDescendants()) do
                    if descendant:IsA("TextLabel") and descendant.Text:lower() == eventNameLower then
                        local a = descendant
                        while a and a ~= propsFolder do
                            if a:IsA("BasePart") then return a end
                            a = a.Parent
                        end
                    end
                end
            end
        end
    end
    return nil
end

-- ===== Worker =====
task.spawn(function()
    while task.wait(5) do
        local S = getgenv().eventSet
        if not S.enabled then continue end

        -- pastikan selectedEvents selalu array
        if type(S.selectedEvents) ~= "table" then
            S.selectedEvents = {}
        end
        -- guard kosong
        if #S.selectedEvents == 0 then continue end

        local char = (Workspace:FindFirstChild("Characters") and Workspace.Characters:FindFirstChild(LocalPlayer.Name))
                    or LocalPlayer.Character
        local hrp  = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then continue end

        local eventPart = nil
        for _, selectedEvent in ipairs(S.selectedEvents) do
            local part = findEventPart(selectedEvent)
            if part then eventPart = part; break end
        end

        if eventPart and not S.isAtEvent then
            S.isAtEvent = true
            S.originalPosition = hrp.CFrame

            pcall(function() if floatPlat then floatPlat(true) end end)
            pcall(function() if FloatPlayer and FloatPlayer.Set then FloatPlayer:Set(true) end end)

            if hrp.Anchored then hrp.Anchored = false end
            hrp.CFrame = eventPart.CFrame * CFrame.new(0, 3, 0)

            pcall(function()
                if lockPositionState and lockPositionState.enabled then
                    lockPositionState.position = hrp.CFrame
                end
            end)

        elseif (not eventPart) and S.isAtEvent then
            pcall(function() if floatPlat then floatPlat(false) end end)
            pcall(function() if FloatPlayer and FloatPlayer.Set then FloatPlayer:Set(false) end end)

            if S.originalPosition then
                if hrp.Anchored then hrp.Anchored = false end
                hrp.CFrame = S.originalPosition
                pcall(function()
                    if lockPositionState and lockPositionState.enabled then
                        lockPositionState.position = hrp.CFrame
                    end
                end)
            end
            S.isAtEvent = false
        end
    end
end)


local IslandsSection = Tabs.Teleport:AddSection("Islands Teleport")
local islandCoordsList = {
    ["01"] = { name = "Crater Island", position = Vector3.new(1014.896, 20.921, 5071.434) },
    ["02"] = { name = "Treasure Room", position = Vector3.new(-3598.539, -279.646, -1634.287) },
    ["03"] = { name = "Lost Shore", position = Vector3.new(-3677, 107, -912) },
    ["04"] = { name = "Fisherman Island", position = Vector3.new(-2.382, 4.5, 2839.47) },
    ["05"] = { name = "Tropical Grove", position = Vector3.new(-2051.413, 6.268, 3662) },
    ["06"] = { name = "Esoteric Depths", position = Vector3.new(3209.068, -1302.855, 1411.844) },
    ["07"] = { name = "Esoteric Island", position = Vector3.new(2031.415, 27.397, 1394.621) },
    ["08"] = { name = "Kohana", position = Vector3.new(-678.811, 4.935, 708.578) },
    ["09"] = { name = "Kohana Volcano", position = Vector3.new(-516.92, 22, 191) },
    ["10"] = { name = "Sisyphus", position = Vector3.new(-3667.556, -135.574, -900.99) },
    ["11"] = { name = "Weather Machine", position = Vector3.new(-1471, -3, 1929) },
    ["12"] = { name = "Winter Fest", position = Vector3.new(1611, 4, 3280) },
    ["13"] = { name = "Coral Reefs", position = Vector3.new(-2949.694, 63.25, 2248.52) },
    ["14"] = { name = "Sacred Temple", position = Vector3.new(1475.197, -21.850, -632.660) },
    ["15"] = { name = "Ancient Jungle", position = Vector3.new(1275.619, 7.858, -194.129) },
    ["16"] = { name = "Ancient Underground Stelar", position = Vector3.new(2100.39917, -91.1976471, -710.773804, 0.122371674, -6.42108589e-09,
        -0.992484331, 1.06256577e-08, 1, -5.15958387e-09, 0.992484331, -9.9144124e-09, 0.122371674) }

}

for _, data in pairs(islandCoordsList) do
    IslandsSection:AddButton({
        Title = data.name, Description = "Teleport to " .. data.name,
        Callback = function()
            pcall(function()
                local charFolder = workspace:WaitForChild("Characters", 5)
                local char = charFolder:FindFirstChild(LocalPlayer.Name); if not char then error("Character not found") end
                local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart", 3)
                if not hrp then error("HumanoidRootPart not found") end
                hrp.CFrame = CFrame.new(data.position + Vector3.new(0,5,0))
            end)
        end
    })
end
-- ================= TELEPORT TO PLAYER (DisplayName) =================
local TPPlayerSection = Tabs.Teleport:AddSection("Teleport to Player")

local SelectedPlayer = nil
local PlayerDropdown
local DisplayNameToUser = {} -- mapping DisplayName -> Username

local function RefreshPlayerList()
    local displayNames = {}
    DisplayNameToUser = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            table.insert(displayNames, p.DisplayName)
            DisplayNameToUser[p.DisplayName] = p.Name
        end
    end
    if PlayerDropdown then
        TPPlayerSection:Remove(PlayerDropdown)
    end
    PlayerDropdown = TPPlayerSection:AddDropdown("PlayerListDropdown", {
        Title = "Select Player",
        Values = displayNames,
        Default = nil,
        Multi = false,
        Callback = function(value)
            SelectedPlayer = value
        end
    })
end

-- ==== STATE ====
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local PlayerList = {}        
local DisplayNameToUser = {}    
local SelectedPlayer = nil    

local PlayerDropdown 

-- ==== UTIL ====
local function getMyHRP()
    local charFolder = workspace:FindFirstChild("Characters")
    local char = (charFolder and charFolder:FindFirstChild(LocalPlayer.Name))
              or LocalPlayer.Character
              or LocalPlayer.CharacterAdded:Wait()
    return char and char:FindFirstChild("HumanoidRootPart")
end

-- ==== REFRESH LIST TANPA :Remove() ====
local function RefreshPlayerList()
    -- kosongkan dengan cara yang benar
    if table.clear then
        table.clear(PlayerList)
        table.clear(DisplayNameToUser)
    else
        -- fallback kalau environment gak punya table.clear
        for k in pairs(PlayerList) do PlayerList[k] = nil end
        for k in pairs(DisplayNameToUser) do DisplayNameToUser[k] = nil end
    end

    for _, p in ipairs(Players:GetPlayers()) do
        -- bikin label yang unik & enak dibaca
        local label = string.format("%s (@%s)", p.DisplayName or p.Name, p.Name)
        table.insert(PlayerList, label)
        DisplayNameToUser[label] = p.Name
    end

    -- update dropdown kalau ada
    if PlayerDropdown then
        pcall(function()
            if PlayerDropdown.SetValues then
                PlayerDropdown:SetValues(PlayerList)
            end
            -- reset selection kalau player sebelumnya udah gak ada
            if SelectedPlayer and not DisplayNameToUser[SelectedPlayer] then
                SelectedPlayer = nil
                if PlayerDropdown.SetValue then
                    PlayerDropdown:SetValue(nil)
                end
            end
        end)
    end
end


RefreshPlayerList()
Players.PlayerAdded:Connect(RefreshPlayerList)
Players.PlayerRemoving:Connect(RefreshPlayerList)

PlayerDropdown = TPPlayerSection:AddDropdown("SelectTPPlayer", {
    Title    = "Select Player",
    Values   = PlayerList,
    Multi    = false,
    Default  = 1,
    Callback = function(choice)
        SelectedPlayer = choice
    end
})

TPPlayerSection:AddButton({
    Title = "Teleport to the Player!",
    Description = "Teleport to selected player",
    Callback = function()
        if not SelectedPlayer then
            if typeof(NotifyHub) == "function" then NotifyHub("Please select a player first!") end
            return
        end
        local username = DisplayNameToUser[SelectedPlayer]
        local target   = username and Players:FindFirstChild(username)

        if target and target.Character then
            local hrpTarget = target.Character:FindFirstChild("HumanoidRootPart")
            local myHRP     = getMyHRP()
            if hrpTarget and myHRP then
                myHRP.CFrame = hrpTarget.CFrame + Vector3.new(0, 3, 0)
                if typeof(NotifyHub) == "function" then NotifyHub("Teleported to "..SelectedPlayer) end
                return
            end
        end
        if typeof(NotifyHub) == "function" then NotifyHub("Target player not found!") end
    end
})

local NPCSection = Tabs.Teleport:AddSection("NPC Teleport")
local npcFolder = ReplicatedStorage:WaitForChild("NPC")
for _, npc in pairs(npcFolder:GetChildren()) do
    if npc:IsA("Model") then
        local hrp = npc:FindFirstChild("HumanoidRootPart") or npc.PrimaryPart
        if hrp then
            NPCSection:AddButton({
                Title = npc.Name, Description = "Teleport to " .. npc.Name,
                Callback = function()
                    local charFolder = workspace:FindFirstChild("Characters", 5)
                    local char = charFolder and charFolder:FindFirstChild(LocalPlayer.Name)
                    if not char then return end
                    local myHRP = char:FindFirstChild("HumanoidRootPart")
                    if myHRP then myHRP.CFrame = hrp.CFrame + Vector3.new(0,3,0) end
                end
            })
        end
    end
end



local autoEnchantState = { enabled = false, targetEnchant = nil, stonesUsed = 0 }

local function getEnchantmentList()
    local enchants = {}
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name then
                table.insert(enchants, data.Data.Name)
            end
        end
    end
    table.sort(enchants)
    return enchants
end

local function getTargetEnchantData(enchantName)
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name == enchantName then
                return data
            end
        end
    end
    return nil
end


local EnchantSection = Tabs.Enchant:AddSection("Auto Enchantment")

-- ====== STATE & HELPERS ======
local autoEnchantState = { enabled = false, targetEnchant = nil, stonesUsed = 0 }

local function getEnchantmentList()
    local enchants = {}
    local ok, enchantsModule = pcall(require, replicatedStorage:WaitForChild("Enchants"))
    if ok and type(enchantsModule) == "table" then
        for _, data in pairs(enchantsModule) do
            if type(data) == "table" and data.Data and data.Data.Name then
                table.insert(enchants, data.Data.Name)
            end
        end
    end
    table.sort(enchants)
    return enchants
end

-- ====== UI: Dropdown target enchant (single-select) ======
EnchantSection:AddDropdown("LH_TargetEnchant_SEL", {
    Title   = "Select Target",
    Values  = getEnchantmentList(),
    Default = nil,
    Multi   = false,
    Callback = function(value)
        if typeof(value) == "table" then value = value[1] end
        autoEnchantState.targetEnchant = value
        if value then
            NotifyHub("Target enchant: " .. tostring(value), 2)
        end
    end
})

EnchantSection:AddToggle("LH_AutoEnchant_TOGGLE", {
    Title   = "Enable Auto Enchant",
    Default = false,
    Callback = function(value)
        autoEnchantState.enabled = value

        if not value then
            NotifyHub("Auto Enchant stopped.", 2)
            return
        end

        task.spawn(function()
            if not autoEnchantState.targetEnchant then
                NotifyHub("Select target enchant first.", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                end)
                return
            end

            -- Teleport ke altar (sesuai source kamu)
            local char = player.Character or player.CharacterAdded:Wait()
            local hrp  = char and char:WaitForChild("HumanoidRootPart", 10)
            if hrp then
                hrp.CFrame = CFrame.new(3234, -1300, 1401)
                task.wait(2)
            end

            -- Require modul (pcall biar aman)
            local okU, localItemUtility   = pcall(require, replicatedStorage.Shared.ItemUtility)
            local okR, localReplion       = pcall(require, replicatedStorage.Packages.Replion)
            if not (okU and okR) then
                NotifyHub("❌ Module missing: ItemUtility/Replion", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                    if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                end)
                return
            end

            -- Remotes (nama dengan slash, sesuai pola game kamu)
            local okN, netFolder = pcall(function()
                return replicatedStorage.Packages["_Index"]["sleitnick_net@0.2.0"].net
            end)
            if not okN or not netFolder then
                NotifyHub("❌ Net folder not found.", 3)
                autoEnchantState.enabled = false
                pcall(function()
                    if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                end)
                return
            end

            local equipItemEvent           = netFolder["RE/EquipItem"]
            local equipToolFromHotbarEvent = netFolder["RE/EquipToolFromHotbar"]
            local activateEnchantAltarEvent= netFolder["RE/ActivateEnchantingAltar"]

            local function getEquippedRod()
                local DataReplion   = localReplion.Client:WaitReplion("Data")
                local equippedItems = DataReplion:Get("EquippedItems")
                if not (equippedItems and equippedItems[1]) then return nil, nil end
                local rodUUID       = equippedItems[1]
                local inventoryRods = DataReplion:Get({"Inventory", "Fishing Rods"})
                if not inventoryRods then return nil, nil end
                for _, item in ipairs(inventoryRods) do
                    if item.UUID == rodUUID then
                        local itemData = localItemUtility:GetItemData(item.Id)
                        if itemData and itemData.Data and itemData.Data.Type == "Fishing Rods" then
                            return item, itemData
                        end
                    end
                end
                return nil, nil
            end

            local function findFirstEnchantStone()
                local DataReplion    = localReplion.Client:WaitReplion("Data")
                local inventoryItems = DataReplion:Get({"Inventory", "Items"})
                if inventoryItems then
                    for _, itemData in ipairs(inventoryItems) do
                        local baseItemData = localItemUtility:GetItemData(itemData.Id)
                        if baseItemData and baseItemData.Data and baseItemData.Data.Type == "EnchantStones" then
                            return itemData.UUID, (itemData.Quantity or 1)
                        end
                    end
                end
                return nil, 0
            end

            local function findStoneInHotbar()
                local DataReplion   = localReplion.Client:WaitReplion("Data")
                local equippedItems = DataReplion:Get("EquippedItems")
                if equippedItems then
                    local invItems = DataReplion:Get({"Inventory", "Items"})
                    for slot, uuid in ipairs(equippedItems) do
                        if invItems then
                            for _, itemData in ipairs(invItems) do
                                if itemData.UUID == uuid then
                                    local baseData = localItemUtility:GetItemData(itemData.Id)
                                    if baseData and baseData.Data and baseData.Data.Type == "EnchantStones" then
                                        return slot
                                    end
                                end
                            end
                        end
                    end
                end
                return nil
            end

            autoEnchantState.stonesUsed = 0
            NotifyHub("Auto Enchant started for: " .. tostring(autoEnchantState.targetEnchant), 3)

            while autoEnchantState.enabled do
                local equippedRod, equippedRodData = getEquippedRod()
                if not equippedRod then
                    NotifyHub("Checking..", 3)
                    autoEnchantState.enabled = false
                    pcall(function()
                        if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                        if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                        if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                    end)
                    break
                end

                local currentEnchantName = "None"
                if equippedRod.Metadata and equippedRod.Metadata.EnchantId then
                    local okE, currentEnchantData = pcall(localItemUtility.GetEnchantData, localItemUtility, equippedRod.Metadata.EnchantId)
                    if okE and currentEnchantData and currentEnchantData.Data then
                        currentEnchantName = currentEnchantData.Data.Name or "Unknown"
                        if currentEnchantName == autoEnchantState.targetEnchant then
                            NotifyHub(("✅ Success! '%s' found after %d stones."):format(
                                autoEnchantState.targetEnchant, autoEnchantState.stonesUsed
                            ), 4)
                            autoEnchantState.enabled = false
                            pcall(function()
                                if autoEnchantToggle and autoEnchantToggle.Set then autoEnchantToggle:Set(false) end
                                if autoEnchantToggle and autoEnchantToggle.SetValue then autoEnchantToggle:SetValue(false) end
                                if autoEnchantToggle and autoEnchantToggle.SetState then autoEnchantToggle:SetState(false) end
                            end)
                            pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, 1)
                            break
                        end
                    end
                end

                local stoneUUID, stoneCount = findFirstEnchantStone()
                if not stoneUUID or stoneCount == 0 then
                    NotifyHub("Waiting Enchant Stones...", 2)
                    task.wait(5)
                    continue
                end

                local stoneHotbarSlot = findStoneInHotbar()
                if not stoneHotbarSlot then
                    pcall(equipItemEvent.FireServer, equipItemEvent, stoneUUID, "EnchantStones")
                    task.wait(0.5)
                    stoneHotbarSlot = findStoneInHotbar()
                    if not stoneHotbarSlot then
                        NotifyHub("❌ Failed equip stone to hotbar.", 3)
                        task.wait(5)
                        continue
                    end
                end

                autoEnchantState.stonesUsed += 1
                NotifyHub(("🔁 Enchant attempt... stones used: %d"):format(autoEnchantState.stonesUsed), 1.5)

                pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, stoneHotbarSlot)
                task.wait(0.2)
                pcall(activateEnchantAltarEvent.FireServer, activateEnchantAltarEvent)
                task.wait(2)
                pcall(equipToolFromHotbarEvent.FireServer, equipToolFromHotbarEvent, 1)
                task.wait(1)
            end
        end)
    end
})

local AutoFavSection = Tabs.Main:AddSection("Auto Favorite")

-- Safe require helpers
local function safeRequire(pathArray)
    local inst = ReplicatedStorage
    for _,name in ipairs(pathArray) do
        inst = inst:FindFirstChild(name)
        if not inst then return nil end
    end
    if not inst:IsA("ModuleScript") then return nil end
    local ok, mod = pcall(require, inst)
    if ok then return mod end
    return nil
end

-- Try require core modules (do not crash if missing)
local TierUtility       = safeRequire({"Shared","TierUtility"})
local ItemUtility       = safeRequire({"Shared","ItemUtility"})
local ItemStringUtility = safeRequire({"Shared","ItemStringUtility"})

-- Try find Replion safely (global or from Packages/_Index)
local Replion = rawget(_G,"Replion") or (getgenv and getgenv().Replion) or nil
if not Replion then
    local idx = ReplicatedStorage:FindFirstChild("Packages")
                 and ReplicatedStorage.Packages:FindFirstChild("_Index")
    if idx then
        for _, folder in ipairs(idx:GetChildren()) do
            local repl = folder:FindFirstChild("replion") or folder:FindFirstChild("Replion")
            if repl and repl:IsA("ModuleScript") then
                local ok, mod = pcall(require, repl)
                if ok then Replion = mod break end
            end
        end
    end
end


local net2 = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index"):WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
local REFavoriteItem = net2:WaitForChild("RE/FavoriteItem")

local FavState = {
    enabled = false,
    selected = {},  
    lastRunAt = 0,
    interval = 6,
}

local RarityDropdownValues = {
    Common     = "Common",
    Uncommon   = "Uncommon",
    Rare       = "Rare",
    Epic       = "Epic",
    Legendary  = "Legendary",
    Mythic     = "Mythic",
    Secret     = "Secret",
}
local function _lw(s) return (tostring(s or ""):lower()) end

local function getTierNameFromItemId(itemId)
    if not ItemUtility then return nil end
    local baseItem = ItemUtility:GetItemData(itemId)
    if not baseItem then return nil end

    local data = baseItem.Data or baseItem.data or baseItem
    local chance = data and data.Probability and tonumber(data.Probability.Chance) or nil

    if chance and TierUtility and TierUtility.GetTierFromRarity then
        local td = TierUtility.GetTierFromRarity(nil, chance)
        if td and td.Name then return tostring(td.Name) end
    end

    local TierMap2 = {
        [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Epic",
        [5]="Legendary",[6]="Mythic",[7]="Secret",
    }
    if data and data.Tier and TierMap2[data.Tier] then
        return TierMap2[data.Tier]
    end
    return nil
end

local function favoriteBySelectedRarities()
    if not Replion then return 0, "Replion module not found" end

    local DataReplion = Replion.Client and Replion.Client:WaitReplion("Data")
    if not DataReplion then return 0, "Data replion not available" end

    local invWrap = DataReplion:Get({"Inventory"})
    if not invWrap or not invWrap.Items then return 0 end

    local count = 0
    for _, v in pairs(invWrap.Items) do
        if not v.Favorited and v.Id then
            local tierName = getTierNameFromItemId(v.Id)
            if tierName and FavState.selected[_lw(tierName)] then
                if v.UUID then
                    pcall(function() REFavoriteItem:FireServer(v.UUID) end)
                    count += 1
                end
            end
        end
    end
    return count
end

AutoFavSection:AddDropdown("FavRarityDropdown", {
    Title = "Choose Rarities to Favorite",
    Description = "Auto favorite fish by rarity",
    Values = RarityDropdownValues,
    Default = {},
    Multi = true,
    Callback = function(map)
        FavState.selected = {}
        if type(map) == "table" then
            for label, chosen in pairs(map) do
                if chosen then FavState.selected[_lw(label)] = true end
            end
        end
    end
})

AutoFavSection:AddToggle("FavRarityToggle", {
    Title = "Enable Auto Favorite",
    Description = "Periodically favorites items of chosen rarities",
    Default = false,
    Callback = function(on)
        FavState.enabled = not not on
        if FavState.enabled then
            local n, err = favoriteBySelectedRarities()
            if err and NotifyHub then
                NotifyHub("Auto Favorite warning: "..tostring(err))
            elseif (n or 0) > 0 and NotifyHub then
                NotifyHub(("Favorited %d items (initial)"):format(n))
            end
        end
    end
})


task.spawn(function()
    while true do
        task.wait(1)
        if FavState.enabled then
            local now = os.clock()
            if now - (FavState.lastRunAt or 0) >= FavState.interval then
                FavState.lastRunAt = now
                local _, err = favoriteBySelectedRarities()
                if err and NotifyHub then
                    NotifyHub("Auto Favorite warning: "..tostring(err))
                end
            end
        end
    end
end)

AutoFavSection:AddToggle("UnFavAllRarity", {
    Title = "Auto UnFavorite All",
    Description = "Unfavorite All Fish",
    Default = false,
    Callback = function()
       unfavoriteAll()
    end
})


AutoFavSection:AddToggle("FavAllRarity", {
    Title = "Auto Favorite All",
    Description = "Favorite All Fish",
    Default = false,
    Callback = function()
        favoriteAll()
    end
})

local HttpService       = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextService       = game:GetService("TextService") -- antisipasi lib UI GetTextSize

-- ===================== CONFIG / STATE =====================
local AUTHOR_ICON = "https://cdn.discordapp.com/attachments/1412614172302381106/1412899628629758122/B43515AA-FBA7-4D37-B830-5C531B5A0158.png"

local WebhookState = {
    url = "",
    enabled = false,
    rarityFilter = {},
    _raritySet = {},
}

-- ========== RARITY FILTER HELPERS ==========
local function _normR(s)
    return (tostring(s or ""):gsub("^%s+",""):gsub("%s+$",""):lower())
end

local function _rebuildRaritySet(vals)
    for k in pairs(WebhookState._raritySet) do WebhookState._raritySet[k] = nil end
    table.clear(WebhookState.rarityFilter)
    if type(vals) ~= "table" then return end

    local hasNum = false
    for k,_ in pairs(vals) do if typeof(k)=="number" then hasNum=true break end end

    if hasNum then
        for _,v in ipairs(vals) do
            local key=_normR(v)
            if key~="" then
                WebhookState._raritySet[key]=true
                table.insert(WebhookState.rarityFilter,v)
            end
        end
    else
        for k,v in pairs(vals) do
            if v then
                local key=_normR(k)
                if key~="" then
                    WebhookState._raritySet[key]=true
                    table.insert(WebhookState.rarityFilter,k)
                end
            end
        end
    end
end

local function _passRarityFilter(r)
    local set = WebhookState._raritySet
    if not set or next(set)==nil then return true end
    return set[_normR(r)] == true
end

-- ===================== UI =====================
local WebhookSection = Tabs.Webhook:AddSection("Webhook Option")

WebhookSection:AddDropdown("RarityWebhook", {
    Title="Choose Rarity",
    Description="No Select = All Rarity",
    Values={ "Common","Uncommon","Rare","Epic","Legendary","Mythic","Secret" },
    Default={},
    Multi=true,
    Callback=function(vals)
        _rebuildRaritySet(vals)
    end
})

WebhookSection:AddInput("WebhookURL", {
    Title="Webhook URL",
    Description="Put Your Webhook",
    Placeholder="https://discord.com/api/webhooks/<ID>/<TOKEN>",
    Default="",
    Callback=function(text)
        WebhookState.url = tostring(text or "")
    end
})

WebhookSection:AddToggle("WebhookToggle", {
    Title="Enable Webhook",
    Description="",
    Default=false,
    Callback=function(on)
        WebhookState.enabled = not not on
    end
})


-- ===================== MAPPING / COLORS =====================
local TierMap = {
    [1]="Common",[2]="Uncommon",[3]="Rare",[4]="Epic",
    [5]="Legendary",[6]="Mythic",[7]="Secret",
}

local RarityColor = {
    Common=0x95A5A6, Uncommon=0x2ECC71, Rare=0x3498DB, Epic=0x9B59B6,
    Legendary=0xF1C40F, Mythic=0xE67E22, Secret=0xE74C3C
}

getgenv().tierArray = getgenv().tierArray or {
    { Name="Common",    Rarity=1,        TierColor=ColorSequence.new(Color3.fromRGB(255,250,246)), Tier=1 },
    { Name="Uncommon",  Rarity=0.02,     TierColor=ColorSequence.new(Color3.fromRGB(195,255,85)),  Tier=2 },
    { Name="Rare",      Rarity=0.004,    TierColor=ColorSequence.new(Color3.fromRGB(85,162,255)),  Tier=3 },
    { Name="Epic",      Rarity=0.001,    TierColor=ColorSequence.new(Color3.fromRGB(173,79,255)),  Tier=4 },
    { Name="Legendary", Rarity=0.0002,   TierColor=ColorSequence.new(Color3.fromRGB(255,184,42)),  Tier=5 },
    { Name="Mythic",    Rarity=0.00002,  TierColor=ColorSequence.new(Color3.fromRGB(255,24,24)),   Tier=6 },
    { Name="SECRET",    Rarity=0.000004, TierColor=ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(23,255,151)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(11,149,255)),
    }), Tier=7 },
}

-- ===== Rarity via Chance (auto pick rarer) =====
local RARITY_ORDER = { "Common","Uncommon","Rare","Epic","Legendary","Mythic","Secret" }
local RARITY_INDEX = {}
for i,n in ipairs(RARITY_ORDER) do RARITY_INDEX[n]=i end

local function pickRarer(a,b)
    if a and not b then return a end
    if b and not a then return b end
    if not a and not b then return nil end
    local ia, ib = RARITY_INDEX[a] or 1, RARITY_INDEX[b] or 1
    return (ia>ib) and a or b
end

local MUT_PREFIX = { ghost=true, stone=true, gold=true, albino=true, shiny=true, big=true, corrupt=true }

local function baseNameForRarity(displayName)
    local words = {}
    for w in tostring(displayName or ""):gmatch("%S+") do table.insert(words, w) end
    if #words==0 then return displayName end
    local first = words[1]:lower()
    if MUT_PREFIX[first] and #words>=2 then
        table.remove(words,1)
        return table.concat(words," ")
    end
    return displayName
end

local function tierNameFromTier(tierNumber)
    if not tierNumber then return nil end
    return TierMap[tierNumber] or "(unknown)"
end

local function _extractAssetId(s)
    if type(s)~="string" then return nil end
    return s:match("rbxassetid://(%d+)") or s:match("(%d+)$")
end

local function _thumbFromAssetId(assetStr)
    local id=_extractAssetId(assetStr)
    if not id then return nil end
    local ok,res=pcall(function()
        local url=("https://thumbnails.roblox.com/v1/assets?assetIds=%s&size=420x420&format=Png&isCircular=false"):format(id)
        local raw=game:HttpGet(url)
        return HttpService:JSONDecode(raw)
    end)
    if ok and res and res.data and res.data[1] and res.data[1].imageUrl then
        return res.data[1].imageUrl
    end
    return nil
end

local function findItemModule(fishDisplayName)
    local Items=ReplicatedStorage:FindFirstChild("Items")
    if not Items then return nil,nil end
    local target=tostring(fishDisplayName or ""):lower():gsub("%s+"," ")
    for _,ms in ipairs(Items:GetDescendants()) do
        if ms:IsA("ModuleScript") then
            local ok,mod=pcall(require,ms)
            if ok and type(mod)=="table" then
                local d=mod.Data or mod.data or mod
                local nm=d and d.Name and tostring(d.Name):lower():gsub("%s+"," ")
                if nm and nm==target then return ms,d,mod end
            end
        end
    end
    return nil,nil
end

local _fishCache = {}
local function resolveFishInfoByName(name)
    if not name or name=="" then return nil end
    local key=name:lower():gsub("[^%w]+"," ")
    if _fishCache[key]~=nil then return _fishCache[key] or nil end

    local _, data, modTable = findItemModule(name)
    if data then
        local tierNum   = tonumber(data.Tier)
        local tierName  = tierNameFromTier(tierNum) or nil
        local sellPrice = tonumber(modTable and modTable.SellPrice) or tonumber(data.SellPrice)
        local chance    = data.Probability and tonumber(data.Probability.Chance) or nil
        local iconUrl   = data.Icon and _thumbFromAssetId(data.Icon) or nil

        local chanceR   = rarityFromChance(chance)
        local tierR     = tierName
        local finalR    = pickRarer(tierR, chanceR) or tierR or chanceR or "Common"

        local info = {
            name      = data.Name or name,
            tier      = tierNum,
            tierName  = tierName or finalR,
            rarity    = finalR,
            sellPrice = sellPrice,
            chance    = chance,
            iconUrl   = iconUrl
        }
        _fishCache[key]=info
        return info
    end
    _fishCache[key]=false
    return nil
end

-- ===================== WEBHOOK SENDER =====================
local function is_valid_webhook(url)
    if type(url)~="string" then return false end
    if url:match("^https://discord%.com/api/webhooks/%d+/.+") or
       url:match("^https://discordapp%.com/api/webhooks/%d+/.+") then return true end
    return false
end

local function send_req(opt)
    local r=(syn and syn.request) or (http and http.request) or http_request or request
    if r then
        local ok,res=pcall(function()
            return r({Url=opt.Url,Method=opt.Method or "POST",Headers=opt.Headers or {["Content-Type"]="application/json"},Body=opt.Body})
        end)
        if ok then return true,res end
        ok,res=pcall(function()
            return r({url=opt.Url,method=opt.Method or "POST",headers=opt.Headers or {["Content-Type"]="application/json"},body=opt.Body})
        end)
        if ok then return true,res end
    end
    local ok,res=pcall(function()
        return HttpService:RequestAsync({Url=opt.Url,Method=opt.Method or "POST",Headers=opt.Headers or {["Content-Type"]="application/json"},Body=opt.Body})
    end)
    return ok,res
end

local function sendCatchEmbedOnce(displayName, info, weight)
    if not info then return end
    if not WebhookState.enabled then return end
    if not is_valid_webhook(WebhookState.url) then return end

    local rarity=tostring(info.rarity or info.tierName or "Unknown")
    if not _passRarityFilter(rarity) then return end

    local embed = {
        author      = { name = "LimitHub | Fish Caught", icon_url = AUTHOR_ICON },
        title       = ("🎣 %s"):format(displayName),
        description = ("**Rarity:** %s"):format(rarity),
        color       = (RarityColor and RarityColor[rarity]) or 0x00BFFF,
        fields      = {
            { name = "Sell Price", value = tostring(info.sellPrice or "N/A"), inline = true },
            { name = "Weight",     value = string.format("%.2f kg", weight or 0), inline = true },
        },
        thumbnail   = info.iconUrl and { url = info.iconUrl } or nil,
        footer      = { text = "discord.gg/limithub" },
        timestamp   = os.date("!%Y-%m-%dT%H:%M:%SZ"),
    }

    send_req({
        Url     = WebhookState.url .. "?wait=true",
        Method  = "POST",
        Headers = { ["Content-Type"] = "application/json" },
        Body    = HttpService:JSONEncode({ embeds = { embed } })
    })
end

-- ===================== EVENT HOOK =====================
local netFolder = ReplicatedStorage
    :WaitForChild("Packages"):WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
local REFishCaught = netFolder:WaitForChild("RE/FishCaught")

REFishCaught.OnClientEvent:Connect(function(itemName, metadata)
    local displayName = tostring(itemName or "")
    local base        = baseNameForRarity(displayName)
    local info        = resolveFishInfoByName(base)
    local weightNum   = metadata and metadata.Weight or nil
    sendCatchEmbedOnce(displayName, info, weightNum)
end)

local SettingsSection = Tabs.Settings:AddSection("Performance & Server")
SettingsSection:AddButton({
    Title = "Boost FPS (Maximize Performance)",
    Description = "Optimize game for better FPS",
    Callback = function()
        for _, v in pairs(game:GetDescendants()) do
            if v:IsA("BasePart") then v.Material = Enum.Material.SmoothPlastic v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then v.Transparency = 1 end
        end
        local Lighting = game:GetService("Lighting")
        for _, effect in pairs(Lighting:GetChildren()) do if effect:IsA("PostEffect") then effect.Enabled = false end end
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 1e10
        settings().Rendering.QualityLevel = "Level01"
    end
})

local TeleportService = game:GetService("TeleportService")
local function Rejoin() local p = Players.LocalPlayer; if p then TeleportService:Teleport(game.PlaceId, p) end end
local function ServerHop()
    local placeId, servers, cursor = game.PlaceId, {}, ""
    repeat
        local url = "https://games.roblox.com/v1/games/"..placeId.."/servers/Public?sortOrder=Asc&limit=100" .. (cursor~="" and ("&cursor="..cursor) or "")
        local ok, result = pcall(function() return HttpService:JSONDecode(game:HttpGet(url)) end)
        if ok and result and result.data then
            for _, server in pairs(result.data) do
                if server.playing < server.maxPlayers and server.id ~= game.JobId then
                    table.insert(servers, server.id)
                end
            end
            cursor = result.nextPageCursor or ""
        else break end
    until not cursor or #servers > 0
    if #servers > 0 then TeleportService:TeleportToPlaceInstance(placeId, servers[math.random(1,#servers)], LocalPlayer) end
end
SettingsSection:AddButton({ Title = "Rejoin Server", Description = "Rejoin the current server", Callback = Rejoin })
SettingsSection:AddButton({ Title = "Server Hop (New Server)", Description = "Hop to a new server", Callback = ServerHop })

--// Services
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local LocalPlayer       = Players.LocalPlayer

Options = Options or getgenv().Options or {}
Toggles = Toggles or getgenv().Toggles or {}

-- UI root
TradeSection = Tabs.Trade:AddSection("Auto Trade")

-- State
local tradeSet = {
	selectedPlayerName = nil,
	selectedPlayerId   = nil,
	selectedItemName   = nil,
	itemQty            = 0,
	autoTradeStart     = false,
}

-- Status
tradeStatus = TradeSection:AddParagraph({ Title = "Status", Desc = "Waiting to start trade..." })

-- Loader
local ItemStringUtility, localReplion, localItemUtility
local modulesLoaded = false
local function loadModulesWithRetry(maxWait)
	local deadline = os.clock() + (maxWait or 6)
	while os.clock() < deadline and not modulesLoaded do
		local ok = pcall(function()
			localReplion      = require(ReplicatedStorage.Packages:WaitForChild("Replion", 2))
			localItemUtility  = require(ReplicatedStorage.Shared:WaitForChild("ItemUtility", 2))
			ItemStringUtility = require(ReplicatedStorage.Modules:WaitForChild("ItemStringUtility", 2))
		end)
		if ok and localReplion and localItemUtility and ItemStringUtility then
			modulesLoaded = true
			break
		end
		task.wait(0.4)
	end
	return modulesLoaded
end
if not loadModulesWithRetry(8) then
	tradeStatus:SetDesc("⚠️ Failed to load Replion/Item modules.")
	return
end

-- Helpers
local function getPlayerList()
	local names = {}
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer then table.insert(names, p.Name) end
	end
	table.sort(names)
	return names
end
local function filterRegex(s)
	if type(s) == "table" then s = s[1] end
	if type(s) ~= "string" then return nil end
	return s:match("^(.-)%s*%(%d+x%)$") or s:match("^(.-)%s*%(%s*Qty%s*:%s*%d+%s*%)$") or s
end
local function getQty(itemData)
	if not itemData then return 1 end
	local n = itemData.Amount or itemData.amount
	      or itemData.Quantity or itemData.quantity
	      or itemData.Count or itemData.count
	      or itemData.Stack or itemData.stack
	      or itemData.Qty or itemData.qty
	n = tonumber(n)
	return (n and n > 0) and n or 1
end
local function stripQtySuffix(s)
	s = tostring(s or "")
	return s:match("^(.-)%s*%(%s*Qty%s*:%s*%d+%s*%)$") or s:match("^(.-)%s*%(%d+x%)$") or s
end

-- Caches
inventoryCache = inventoryCache or {}
local inventoryDropdownList = {}

-- === BUAT DROPDOWN + SIMPAN REFERENSINYA ===
do
	local obj = TradeSection:AddDropdown("InventorySelect", {
		Title       = "Select Fish from Backpack",
		Description = "Only unfavorited Fishes & Enchant Stones listed",
		Values      = {},
		Default     = nil,
		Multi       = false,
		Callback    = function(val) tradeSet.selectedItemName = val end
	})
	Options.InventorySelect = obj
end

do
	local obj = TradeSection:AddDropdown("TradeTarget", {
		Title       = "Select Target",
		Description = "Select player to trade with",
		Values      = getPlayerList(),
		Default     = nil,
		Multi       = false,
		Callback    = function(name)
			tradeSet.selectedPlayerName = name
			tradeSet.selectedPlayerId   = nil
			local chars = Workspace:FindFirstChild("Characters")
			local targetChar = chars and chars:FindFirstChild(name)
			if targetChar then
				local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
				if targetPlayer then tradeSet.selectedPlayerId = targetPlayer.UserId end
			end
		end
	})
	Options.TradeTarget = obj
end

-- Setter aman
local function setDropdownValuesSafe(opt, values, clearSelection)
	if not opt then return end
	values = values or {}

	if typeof(opt.SetValues) == "function" then
		opt:SetValues(values)
	elseif typeof(opt.Refresh) == "function" then
		opt:Refresh(values)
	else
		opt.Values = values
		if typeof(opt.Refresh) == "function" then opt:Refresh() end
	end

	if clearSelection and typeof(opt.SetValue) == "function" then
		pcall(function() opt:SetValue(nil, true) end)
	end
end

-- Refresh inventory
function refreshInventory()
	if not loadModulesWithRetry(6) then
		tradeStatus:SetDesc("⚠️ Modules not ready.")
		setDropdownValuesSafe(Options.InventorySelect, {}, true)
		return
	end

	local okRep, DataRep = pcall(function() return localReplion.Client:WaitReplion("Data") end)
	if not okRep or not DataRep then
		tradeStatus:SetDesc("⚠️ Replion 'Data' not ready.")
		setDropdownValuesSafe(Options.InventorySelect, {}, true)
		return
	end

	local items = DataRep:Get({"Inventory", "Items"})
	inventoryCache        = {}
	inventoryDropdownList = {}

	if not items then
		tradeStatus:SetDesc("⚠️ Inventory empty or not replicated.")
		setDropdownValuesSafe(Options.InventorySelect, {}, true)
		return
	end

	local grouped = {}  -- cleanName -> total qty
	for _, item in ipairs(items) do
		local base = localItemUtility:GetItemData(item.Id)
		if base and base.Data then
			local t = base.Data.Type
			if (t == "Fishes" or t == "EnchantStones") and not item.Favorited then
				local dynName = ItemStringUtility.GetItemName(item, base)
				local clean   = stripQtySuffix(dynName)
				local qty     = getQty(item)

				grouped[clean] = (grouped[clean] or 0) + qty

				inventoryCache[clean] = inventoryCache[clean] or {}
				for i = 1, qty do
					table.insert(inventoryCache[clean], item.UUID) -- duplikat per-qty
				end
			end
		end
	end

	for name, count in pairs(grouped) do
		table.insert(inventoryDropdownList, string.format("%s (Qty : %d)", name, count))
	end
	table.sort(inventoryDropdownList)

	setDropdownValuesSafe(Options.InventorySelect, inventoryDropdownList, true)
	setDropdownValuesSafe(Options.TradeTarget, getPlayerList(), false)

	tradeStatus:SetDesc(string.format("✅ Backpack loaded: %d entries", #inventoryDropdownList))
end

-- Button & auto init
TradeSection:AddButton({
	Title       = "Refresh Backpack",
	Description = "Reload unfavorited fishes & enchant stones",
	Callback    = function()
		refreshInventory()
		print("[Trade] Backpack refreshed.")
	end
})
task.defer(refreshInventory)

-- Input qty
TradeSection:AddInput("TradeQty", {
	Title       = "Quantity to Trade",
	Description = "Enter quantity for selected item",
	Placeholder = "5",
	Default     = "",
	Callback    = function(val) tradeSet.itemQty = tonumber(val) or 0 end
})

-- Keep player list fresh
Players.PlayerAdded:Connect(function()
	if Options.TradeTarget and not Options.TradeTarget.Opened then
		setDropdownValuesSafe(Options.TradeTarget, getPlayerList(), false)
	end
end)
Players.PlayerRemoving:Connect(function()
	if Options.TradeTarget and not Options.TradeTarget.Opened then
		setDropdownValuesSafe(Options.TradeTarget, getPlayerList(), false)
	end
end)

-- Optional block noisy remote
getgenv().oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
	local method = getnamecallmethod()
	if method == "FireServer" and tostring(self) == "URE/UpdateOxygen" then
		return nil
	end
	return getgenv().oldNamecall(self, ...)
end))

-- Start Trade
TradeSection:AddToggle("StartTrade", {
	Title   = "Start Trade!",
	Default = false,
	Callback = function(on)
		tradeSet.autoTradeStart = on
		if not on then
			tradeStatus:SetDesc("Trade stopped.")
			return
		end

		task.spawn(function()
			local chars      = Workspace:FindFirstChild("Characters")
			local targetChar = chars and chars:FindFirstChild(tradeSet.selectedPlayerName)
			local targetPlr  = targetChar and Players:GetPlayerFromCharacter(targetChar)
			local hrp        = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			local targetHRP  = targetChar and targetChar:FindFirstChild("HumanoidRootPart")

			if not (targetPlr and targetHRP and hrp and tradeSet.selectedPlayerId) then
				tradeStatus:SetDesc("Error: invalid target / position / ID.")
				tradeSet.autoTradeStart = false
				return
			end

			hrp.CFrame = targetHRP.CFrame
			task.wait(0.4)

			local selected    = tradeSet.selectedItemName
			local cleanName   = filterRegex(selected) or selected
			local uuidsToSend = inventoryCache[cleanName]

			if not uuidsToSend or #uuidsToSend == 0 then
				tradeStatus:SetDesc("No items found for " .. tostring(cleanName))
				tradeSet.autoTradeStart = false
				return
			end
			if tradeSet.itemQty <= 0 or #uuidsToSend < tradeSet.itemQty then
				tradeStatus:SetDesc("Not enough items for " .. tostring(cleanName))
				tradeSet.autoTradeStart = false
				return
			end

			local netFolder = ReplicatedStorage:WaitForChild("Packages"):WaitForChild("_Index")
				:WaitForChild("sleitnick_net@0.2.0"):WaitForChild("net")
			local RF = netFolder:WaitForChild("RF/InitiateTrade")

			local successCount, failCount = 0, 0
			for i = 1, tradeSet.itemQty do
				if not tradeSet.autoTradeStart then
					tradeStatus:SetDesc("Trade stopped.")
					return
				end
				local uuid = uuidsToSend[i]
				local ok, res = pcall(RF.InvokeServer, RF, tradeSet.selectedPlayerId, uuid)
				if ok and res then successCount += 1 else failCount += 1 end
				tradeStatus:SetDesc(string.format("[%s] Success: %d | Fail: %d", cleanName, successCount, failCount))
				task.wait(3)
			end

			tradeStatus:SetDesc(string.format("✅ Complete. Success: %d | Failed: %d", successCount, failCount))
			tradeSet.autoTradeStart = false
			refreshInventory()
		end)
	end
})

local Players           = game:GetService("Players")
local Workspace         = game:GetService("Workspace")
local LocalPlayer       = Players.LocalPlayer

local AutoArti = Tabs.Main:AddSection("Auto Artifact")

-- // Replion loader
local okRep, Replion = pcall(function()
    return require(ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Replion"))
end)
if not okRep or not Replion then
    AutoArti:AddParagraph({ Title = "Temple Artifact Progress", Desc = "⚠️ Replion not found." })
    return
end

-- // Artifact Data
local ArtifactIDs = {
    ["Arrow Artifact"]             = 265,
    ["Crescent Artifact"]          = 266,
    ["Diamond Artifact"]           = 267,
    ["Hourglass Diamond Artifact"] = 271,
}

local ArtifactSpots = {
    ["Hourglass Diamond Artifact"] = CFrame.new(1500.73401, 6.62499952, -852.561646),
    ["Diamond Artifact"]           = CFrame.new(1833.32751, 4.84496784, -325.866364),
    ["Arrow Artifact"]             = CFrame.new(879.856628, 5.12086105, -342.661469),
    ["Crescent Artifact"]          = CFrame.new(1380.41638, 2.73220325, 115.727127),
}

-- // Remote (Safe path)
local NetFolder = ReplicatedStorage:FindFirstChild("Packages")
    and ReplicatedStorage.Packages:FindFirstChild("_Index")
    and ReplicatedStorage.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
    and ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"]:FindFirstChild("net")

local RE_PlaceLever = NetFolder and NetFolder:FindFirstChild("RE/PlaceLeverItem")

-- // Status paragraph
local para = AutoArti:AddParagraph({
    Title = "Temple Artifact Progress",
    Desc  = "Loading..."
})

-- // Replion Data
local function getReplionData()
    local ok, data = pcall(function()
        return Replion.Client:WaitReplion("Data", LocalPlayer)
    end)
    return ok and data or nil
end

local function readStatus()
    local data = getReplionData()
    if not data then return {}, {}, "Replion Data not ready." end

    local templeLevers, inv = {}, {}
    pcall(function() templeLevers = data:Get("TempleLevers") or {} end)
    pcall(function() inv = data:Get({"Inventory","Items"}) or {} end)

    local owned = {}
    for _, item in ipairs(inv) do
        for name, id in pairs(ArtifactIDs) do
            if item.Id == id then
                owned[name] = true
            end
        end
    end

    return templeLevers, owned, nil
end

-- // Build progress text
local function buildText()
    local levers, owned, err = readStatus()
    if err then return "⚠️ "..err end

    local lines = {}
    for name,_ in pairs(ArtifactIDs) do
        local placed = levers[name] and "⚙️" or "⛔"
        local have   = owned[name] and "✅" or "❌"
        table.insert(lines, string.format("%s %s  (%s Owned)", placed, name, have))
    end

    table.sort(lines)
    local allPlaced = true
    for name,_ in pairs(ArtifactIDs) do
        if not levers[name] then allPlaced = false break end
    end
    if allPlaced then
        table.insert(lines, "\n✅ All levers placed successfully!")
    end
    return table.concat(lines, "\n")
end

-- // Teleport safely
local function safeTeleport(cf)
    local char = LocalPlayer.Character
    if not (char and cf) then return false end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    hrp.CFrame = cf
    task.wait(0.4)
    return true
end

-- // Find next task (teleport or place)
local function pickNextTask()
    local levers, owned = readStatus()

    for name,_ in pairs(ArtifactIDs) do
        if not owned[name] then
            return "teleport", name
        end
    end

    for name,_ in pairs(ArtifactIDs) do
        if owned[name] and not levers[name] then
            return "place", name
        end
    end

    return "done", nil
end

-- // Update paragraph initially
para:SetDesc(buildText())

-- // Buttons
AutoArti:AddButton({
    Title = "Refresh Status",
    Description = "Manually refresh your artifact progress.",
    Callback = function()
        para:SetDesc(buildText())
    end
})

AutoArti:AddButton({
    Title = "Teleport to Next Artifact",
    Description = "Teleport to the next missing artifact location (safe).",
    Callback = function()
        local action, name = pickNextTask()
        if action ~= "teleport" then
            para:SetDesc(buildText().."\n\nℹ️ No missing artifact to farm.")
            return
        end
        local cf = ArtifactSpots[name]
        if not cf then
            para:SetDesc(buildText().."\n\n⚠️ Location not found for: "..name)
            return
        end
        local ok = safeTeleport(cf)
        if ok then
            para:SetDesc(buildText().."\n\n🚀 Teleported to: "..name)
        else
            para:SetDesc(buildText().."\n\n⚠️ Teleport failed (missing HRP).")
        end
    end
})

AutoArti:AddButton({
    Title = "Place Next Lever",
    Description = "Places the next available lever for owned artifacts.",
    Callback = function()
        local action, name = pickNextTask()
        if action ~= "place" then
            para:SetDesc(buildText().."\n\nℹ️ No lever needs to be placed.")
            return
        end
        if not RE_PlaceLever then
            para:SetDesc(buildText().."\n\n⚠️ Remote 'RE/PlaceLeverItem' not found.")
            return
        end

        pcall(function() RE_PlaceLever:FireServer(name) end)
        task.wait(1.0)
        para:SetDesc(buildText().."\n\n🔧 Lever placed for: "..name)
    end
})

do
    -- ==== use existing services/globals if present (no overrides) ====
    local RS   = (replicatedStorage or game:GetService("ReplicatedStorage"))
    local P    = (Players or game:GetService("Players"))
    local LP   = (player or (P and P.LocalPlayer) or game:GetService("Players").LocalPlayer)
    local WS   = (Workspace or game:GetService("Workspace"))

    -- ==== LimitHub UI section (does not redeclare Tabs/Main) ====
    local AutoArti = Tabs.Main:AddSection("Auto Artifact")

    -- ==== Replion (reuse your Client if already required) ====
    local ReplionClient
    do
        local ok, mod = pcall(function()
            if Client and Client.WaitReplion then
                return Client -- your existing Replion client
            end
            return require(RS:WaitForChild("Packages"):WaitForChild("Replion")).Client
        end)
        if ok and mod then ReplionClient = mod end
    end

    -- If Replion is missing, bail safely
    if not ReplionClient then
        AutoArti:AddParagraph({ Title = "Temple Artifact Progress", Desc = "⚠️ Replion client not found." })
        return
    end

    -- ==== artifact id + positions (no globals) ====
    local ArtifactIDs = {
        ["Arrow Artifact"]             = 265,
        ["Crescent Artifact"]          = 266,
        ["Diamond Artifact"]           = 267,
        ["Hourglass Diamond Artifact"] = 271,
    }

    local ArtifactSpots = {
        ["Hourglass Diamond Artifact"] = CFrame.new(1500.73401, 6.62499952, -852.561646),
        ["Diamond Artifact"]           = CFrame.new(1833.32751, 4.84496784, -325.866364),
        ["Arrow Artifact"]             = CFrame.new(879.856628, 5.12086105, -342.661469),
        ["Crescent Artifact"]          = CFrame.new(1380.41638, 2.73220325, 115.727127),
    }

    -- ==== remotes (own table; never touches your global Remotes) ====
    local ArtiRemotes = {}
    do
        local netFolder = RS:FindFirstChild("Packages")
            and RS.Packages:FindFirstChild("_Index")
            and RS.Packages._Index:FindFirstChild("sleitnick_net@0.2.0")
            and RS.Packages._Index["sleitnick_net@0.2.0"]:FindFirstChild("net")

        if netFolder then
            ArtiRemotes.PlaceLever = netFolder:FindFirstChild("RE/PlaceLeverItem")
        end
    end

    -- ==== status paragraph (UI-safe) ====
    local para = AutoArti:AddParagraph({
        Title = "Temple Artifact Progress",
        Desc  = "Loading..."
    })

    -- ==== helpers ====
    local function getData()
        local ok, data = pcall(function()
            return ReplionClient:WaitReplion("Data", LP)
        end)
        return ok and data or nil
    end

    local function readStatus()
        local data = getData()
        if not data then return {}, {}, "Data replion not ready" end

        local levers = {}
        local inv    = {}

        pcall(function() levers = data:Get("TempleLevers") or {} end)
        pcall(function() inv    = data:Get({"Inventory","Items"}) or {} end)

        local owned = {}
        for _, item in ipairs(inv) do
            for name, id in pairs(ArtifactIDs) do
                if item.Id == id then
                    owned[name] = true
                end
            end
        end
        return levers, owned, nil
    end

    local function buildText()
        local levers, owned, err = readStatus()
        if err then return "⚠️ "..err end

        local lines = {}
        for name,_ in pairs(ArtifactIDs) do
            local placed = levers[name] and "⚙️" or "⛔"
            local have   = owned[name]   and "✅" or "❌"
            table.insert(lines, string.format("%s %s  (%s Owned)", placed, name, have))
        end
        table.sort(lines)

        local allPlaced = true
        for name,_ in pairs(ArtifactIDs) do
            if not levers[name] then allPlaced = false break end
        end
        if allPlaced then table.insert(lines, "\n✅ All levers placed!") end

        return table.concat(lines, "\n")
    end

    local function safeTeleport(cf)
        local char = LP and LP.Character
        local hrp  = char and char:FindFirstChild("HumanoidRootPart")
        if not (hrp and cf) then return false end
        hrp.CFrame = cf
        task.wait(0.4)
        return true
    end

    local function nextTask()
        local levers, owned = readStatus()

        for name,_ in pairs(ArtifactIDs) do
            if not owned[name] then
                return "teleport", name
            end
        end
        for name,_ in pairs(ArtifactIDs) do
            if owned[name] and not levers[name] then
                return "place", name
            end
        end
        return "done", nil
    end

    -- initial render
    para:SetDesc(buildText())

    -- ==== buttons (no loops, safe delays) ====
    AutoArti:AddButton({
        Title = "Refresh Status",
        Description = "Update the artifact progress text",
        Callback = function()
            para:SetDesc(buildText())
        end
    })

    AutoArti:AddButton({
        Title = "Teleport to Next Artifact",
        Description = "Teleports you to the next missing artifact location",
        Callback = function()
            local action, name = nextTask()
            if action ~= "teleport" then
                para:SetDesc(buildText().."\n\nℹ️ No missing artifact to farm.")
                return
            end
            local cf = ArtifactSpots[name]
            if not cf then
                para:SetDesc(buildText().."\n\n⚠️ Missing location for: "..name)
                return
            end
            if safeTeleport(cf) then
                para:SetDesc(buildText().."\n\n🚀 Teleported to: "..name)
            else
                para:SetDesc(buildText().."\n\n⚠️ Teleport failed (no HRP).")
            end
        end
    })

    AutoArti:AddButton({
        Title = "Place Next Lever",
        Description = "Places the lever for the next owned-but-unplaced artifact",
        Callback = function()
            local action, name = nextTask()
            if action ~= "place" then
                para:SetDesc(buildText().."\n\nℹ️ No lever needs placing.")
                return
            end
            if not (ArtiRemotes and ArtiRemotes.PlaceLever) then
                para:SetDesc(buildText().."\n\n⚠️ Remote 'RE/PlaceLeverItem' not found.")
                return
            end
            pcall(function() ArtiRemotes.PlaceLever:FireServer(name) end)
            task.wait(1.0)
            para:SetDesc(buildText().."\n\n🔧 Lever placed for: "..name)
        end
    })
end
